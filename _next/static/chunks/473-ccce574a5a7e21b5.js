(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
	[473], {
		2604: function(t, e, n) {
			const i = n(7378);
			const o = i.forwardRef((function({
				title: t,
				titleId: e,
				...n
			}, o) {
				return i.createElement("svg", Object.assign({
					xmlns: "http://www.w3.org/2000/svg",
					fill: "none",
					viewBox: "0 0 24 24",
					strokeWidth: 1.5,
					stroke: "currentColor",
					"aria-hidden": "true",
					ref: o,
					"aria-labelledby": e
				}, n), t ? i.createElement("title", {
					id: e
				}, t) : null, i.createElement("path", {
					strokeLinecap: "round",
					strokeLinejoin: "round",
					d: "M19.5 13.5L12 21m0 0l-7.5-7.5M12 21V3"
				}))
			}));
			t.exports = o
		},
		7927: function(t, e, n) {
			const i = n(7378);
			const o = i.forwardRef((function({
				title: t,
				titleId: e,
				...n
			}, o) {
				return i.createElement("svg", Object.assign({
					xmlns: "http://www.w3.org/2000/svg",
					fill: "none",
					viewBox: "0 0 24 24",
					strokeWidth: 1.5,
					stroke: "currentColor",
					"aria-hidden": "true",
					ref: o,
					"aria-labelledby": e
				}, n), t ? i.createElement("title", {
					id: e
				}, t) : null, i.createElement("path", {
					strokeLinecap: "round",
					strokeLinejoin: "round",
					d: "M10.5 19.5L3 12m0 0l7.5-7.5M3 12h18"
				}))
			}));
			t.exports = o
		},
		4641: function(t, e, n) {
			const i = n(7378);
			const o = i.forwardRef((function({
				title: t,
				titleId: e,
				...n
			}, o) {
				return i.createElement("svg", Object.assign({
					xmlns: "http://www.w3.org/2000/svg",
					fill: "none",
					viewBox: "0 0 24 24",
					strokeWidth: 1.5,
					stroke: "currentColor",
					"aria-hidden": "true",
					ref: o,
					"aria-labelledby": e
				}, n), t ? i.createElement("title", {
					id: e
				}, t) : null, i.createElement("path", {
					strokeLinecap: "round",
					strokeLinejoin: "round",
					d: "M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0013.803-3.7M4.031 9.865a8.25 8.25 0 0113.803-3.7l3.181 3.182m0-4.991v4.99"
				}))
			}));
			t.exports = o
		},
		6652: function(t, e, n) {
			const i = n(7378);
			const o = i.forwardRef((function({
				title: t,
				titleId: e,
				...n
			}, o) {
				return i.createElement("svg", Object.assign({
					xmlns: "http://www.w3.org/2000/svg",
					fill: "none",
					viewBox: "0 0 24 24",
					strokeWidth: 1.5,
					stroke: "currentColor",
					"aria-hidden": "true",
					ref: o,
					"aria-labelledby": e
				}, n), t ? i.createElement("title", {
					id: e
				}, t) : null, i.createElement("path", {
					strokeLinecap: "round",
					strokeLinejoin: "round",
					d: "M13.5 4.5L21 12m0 0l-7.5 7.5M21 12H3"
				}))
			}));
			t.exports = o
		},
		3468: function(t, e, n) {
			const i = n(7378);
			const o = i.forwardRef((function({
				title: t,
				titleId: e,
				...n
			}, o) {
				return i.createElement("svg", Object.assign({
					xmlns: "http://www.w3.org/2000/svg",
					fill: "none",
					viewBox: "0 0 24 24",
					strokeWidth: 1.5,
					stroke: "currentColor",
					"aria-hidden": "true",
					ref: o,
					"aria-labelledby": e
				}, n), t ? i.createElement("title", {
					id: e
				}, t) : null, i.createElement("path", {
					strokeLinecap: "round",
					strokeLinejoin: "round",
					d: "M4.5 10.5L12 3m0 0l7.5 7.5M12 3v18"
				}))
			}));
			t.exports = o
		},
		8728: function(t, e, n) {
			const i = n(7378);
			const o = i.forwardRef((function({
				title: t,
				titleId: e,
				...n
			}, o) {
				return i.createElement("svg", Object.assign({
					xmlns: "http://www.w3.org/2000/svg",
					fill: "none",
					viewBox: "0 0 24 24",
					strokeWidth: 1.5,
					stroke: "currentColor",
					"aria-hidden": "true",
					ref: o,
					"aria-labelledby": e
				}, n), t ? i.createElement("title", {
					id: e
				}, t) : null, i.createElement("path", {
					strokeLinecap: "round",
					strokeLinejoin: "round",
					d: "M17.25 6.75L22.5 12l-5.25 5.25m-10.5 0L1.5 12l5.25-5.25m7.5-3l-4.5 16.5"
				}))
			}));
			t.exports = o
		},
		895: function(t, e, n) {
			const i = n(7378);
			const o = i.forwardRef((function({
				title: t,
				titleId: e,
				...n
			}, o) {
				return i.createElement("svg", Object.assign({
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 24 24",
					fill: "currentColor",
					"aria-hidden": "true",
					ref: o,
					"aria-labelledby": e
				}, n), t ? i.createElement("title", {
					id: e
				}, t) : null, i.createElement("path", {
					fillRule: "evenodd",
					d: "M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12zm13.36-1.814a.75.75 0 10-1.22-.872l-3.236 4.53L9.53 12.22a.75.75 0 00-1.06 1.06l2.25 2.25a.75.75 0 001.14-.094l3.75-5.25z",
					clipRule: "evenodd"
				}))
			}));
			t.exports = o
		},
		2625: function(t, e, n) {
			"use strict";
			n.d(e, {
				O: function() {
					return N
				}
			});
			var i = n(7378),
				o = n(6616),
				r = n(2652),
				s = n(7953),
				a = n(7723),
				l = n(4818),
				u = n(5804),
				c = n(2296),
				h = n(2722),
				d = n(7349),
				p = n(4784);

			function m({
				onFocus: t
			}) {
				let [e, n] = (0, i.useState)(!0);
				return e ? i.createElement(p._, {
					as: "button",
					type: "button",
					features: p.A.Focusable,
					onFocus: e => {
						e.preventDefault();
						let i, o = 50;
						i = requestAnimationFrame((function e() {
							if (!(o-- <= 0)) return t() ? (n(!1), void cancelAnimationFrame(i)) : void(i = requestAnimationFrame(e));
							i && cancelAnimationFrame(i)
						}))
					}
				}) : null
			}
			var f = n(1981),
				v = n(6661),
				g = n(458);
			const y = i.createContext(null);

			function x({
				children: t
			}) {
				let e = i.useRef({
					groups: new Map,
					get(t, e) {
						var n;
						let i = this.groups.get(t);
						i || (i = new Map, this.groups.set(t, i));
						let o = null != (n = i.get(e)) ? n : 0;
						return i.set(e, o + 1), [Array.from(i.keys()).indexOf(e), function() {
							let t = i.get(e);
							t > 1 ? i.set(e, t - 1) : i.delete(e)
						}]
					}
				});
				return i.createElement(y.Provider, {
					value: e
				}, t)
			}

			function b(t) {
				let e = i.useContext(y);
				if (!e) throw new Error("You must wrap your component in a <StableCollection>");
				let n = function() {
						var t, e, n;
						let o = null != (n = null == (e = null == (t = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) ? void 0 : t.ReactCurrentOwner) ? void 0 : e.current) ? n : null;
						if (!o) return Symbol();
						let r = [],
							s = o;
						for (; s;) r.push(s.index), s = s.return;
						return "$." + r.join(".")
					}(),
					[o, r] = e.current.get(t, n);
				return i.useEffect((() => r), []), o
			}
			var w, E, T, P = ((T = P || {})[T.Forwards = 0] = "Forwards", T[T.Backwards = 1] = "Backwards", T),
				V = ((E = V || {})[E.Less = -1] = "Less", E[E.Equal = 0] = "Equal", E[E.Greater = 1] = "Greater", E),
				A = ((w = A || {})[w.SetSelectedIndex = 0] = "SetSelectedIndex", w[w.RegisterTab = 1] = "RegisterTab", w[w.UnregisterTab = 2] = "UnregisterTab", w[w.RegisterPanel = 3] = "RegisterPanel", w[w.UnregisterPanel = 4] = "UnregisterPanel", w);
			let S = {
					0(t, e) {
						var n;
						let i = (0, l.z2)(t.tabs, (t => t.current)),
							o = (0, l.z2)(t.panels, (t => t.current)),
							r = i.filter((t => {
								var e;
								return !(null != (e = t.current) && e.hasAttribute("disabled"))
							})),
							a = {
								...t,
								tabs: i,
								panels: o
							};
						if (e.index < 0 || e.index > i.length - 1) {
							let n = (0, s.E)(Math.sign(e.index - t.selectedIndex), {
								[-1]: () => 1,
								0: () => (0, s.E)(Math.sign(e.index), {
									[-1]: () => 0,
									0: () => 0,
									1: () => 1
								}),
								1: () => 0
							});
							return 0 === r.length ? a : {
								...a,
								selectedIndex: (0, s.E)(n, {
									0: () => i.indexOf(r[0]),
									1: () => i.indexOf(r[r.length - 1])
								})
							}
						}
						let u = i.slice(0, e.index),
							c = [...i.slice(e.index), ...u].find((t => r.includes(t)));
						if (!c) return a;
						let h = null != (n = i.indexOf(c)) ? n : t.selectedIndex;
						return -1 === h && (h = t.selectedIndex), {
							...a,
							selectedIndex: h
						}
					},
					1(t, e) {
						var n;
						if (t.tabs.includes(e.tab)) return t;
						let i = t.tabs[t.selectedIndex],
							o = (0, l.z2)([...t.tabs, e.tab], (t => t.current)),
							r = null != (n = o.indexOf(i)) ? n : t.selectedIndex;
						return -1 === r && (r = t.selectedIndex), {
							...t,
							tabs: o,
							selectedIndex: r
						}
					},
					2: (t, e) => ({
						...t,
						tabs: t.tabs.filter((t => t !== e.tab))
					}),
					3: (t, e) => t.panels.includes(e.panel) ? t : {
						...t,
						panels: (0, l.z2)([...t.panels, e.panel], (t => t.current))
					},
					4: (t, e) => ({
						...t,
						panels: t.panels.filter((t => t !== e.panel))
					})
				},
				C = (0, i.createContext)(null);

			function M(t) {
				let e = (0, i.useContext)(C);
				if (null === e) {
					let e = new Error(`<${t} /> is missing a parent <Tab.Group /> component.`);
					throw Error.captureStackTrace && Error.captureStackTrace(e, M), e
				}
				return e
			}
			C.displayName = "TabsDataContext";
			let R = (0, i.createContext)(null);

			function k(t) {
				let e = (0, i.useContext)(R);
				if (null === e) {
					let e = new Error(`<${t} /> is missing a parent <Tab.Group /> component.`);
					throw Error.captureStackTrace && Error.captureStackTrace(e, k), e
				}
				return e
			}

			function L(t, e) {
				return (0, s.E)(e.type, S, t, e)
			}
			R.displayName = "TabsActionsContext";
			let D = i.Fragment;
			let B = o.AN.RenderStrategy | o.AN.Static;
			let I = (0, o.yV)((function(t, e) {
					var n, d;
					let p = (0, r.M)(),
						{
							id: m = `headlessui-tabs-tab-${p}`,
							...y
						} = t,
						{
							orientation: x,
							activation: w,
							selectedIndex: E,
							tabs: T,
							panels: P
						} = M("Tab"),
						V = k("Tab"),
						A = M("Tab"),
						S = (0, i.useRef)(null),
						C = (0, c.T)(S, e);
					(0, u.e)((() => V.registerTab(S)), [V, S]);
					let R = b("tabs"),
						L = T.indexOf(S); - 1 === L && (L = R);
					let D = L === E,
						B = (0, f.z)((t => {
							var e;
							let n = t();
							if (n === l.fE.Success && "auto" === w) {
								let t = null == (e = (0, g.r)(S)) ? void 0 : e.activeElement,
									n = A.tabs.findIndex((e => e.current === t)); - 1 !== n && V.change(n)
							}
							return n
						})),
						I = (0, f.z)((t => {
							let e = T.map((t => t.current)).filter(Boolean);
							if (t.key === a.R.Space || t.key === a.R.Enter) return t.preventDefault(), t.stopPropagation(), void V.change(L);
							switch (t.key) {
								case a.R.Home:
								case a.R.PageUp:
									return t.preventDefault(), t.stopPropagation(), B((() => (0, l.jA)(e, l.TO.First)));
								case a.R.End:
								case a.R.PageDown:
									return t.preventDefault(), t.stopPropagation(), B((() => (0, l.jA)(e, l.TO.Last)))
							}
							return B((() => (0, s.E)(x, {
								vertical: () => t.key === a.R.ArrowUp ? (0, l.jA)(e, l.TO.Previous | l.TO.WrapAround) : t.key === a.R.ArrowDown ? (0, l.jA)(e, l.TO.Next | l.TO.WrapAround) : l.fE.Error,
								horizontal: () => t.key === a.R.ArrowLeft ? (0, l.jA)(e, l.TO.Previous | l.TO.WrapAround) : t.key === a.R.ArrowRight ? (0, l.jA)(e, l.TO.Next | l.TO.WrapAround) : l.fE.Error
							}))) === l.fE.Success ? t.preventDefault() : void 0
						})),
						j = (0, i.useRef)(!1),
						O = (0, f.z)((() => {
							var t;
							j.current || (j.current = !0, null == (t = S.current) || t.focus(), V.change(L), (0, v.Y)((() => {
								j.current = !1
							})))
						})),
						F = (0, f.z)((t => {
							t.preventDefault()
						})),
						U = (0, i.useMemo)((() => ({
							selected: D
						})), [D]),
						N = {
							ref: C,
							onKeyDown: I,
							onMouseDown: F,
							onClick: O,
							id: m,
							role: "tab",
							type: (0, h.f)(t, S),
							"aria-controls": null == (d = null == (n = P[L]) ? void 0 : n.current) ? void 0 : d.id,
							"aria-selected": D,
							tabIndex: D ? 0 : -1
						};
					return (0, o.sY)({
						ourProps: N,
						theirProps: y,
						slot: U,
						defaultTag: "button",
						name: "Tabs.Tab"
					})
				})),
				j = (0, o.yV)((function(t, e) {
					let {
						defaultIndex: n = 0,
						vertical: r = !1,
						manual: s = !1,
						onChange: a,
						selectedIndex: h = null,
						...p
					} = t;
					const v = r ? "vertical" : "horizontal",
						g = s ? "manual" : "auto";
					let y = null !== h,
						b = (0, c.T)(e),
						[w, E] = (0, i.useReducer)(L, {
							selectedIndex: null != h ? h : n,
							tabs: [],
							panels: []
						}),
						T = (0, i.useMemo)((() => ({
							selectedIndex: w.selectedIndex
						})), [w.selectedIndex]),
						P = (0, d.E)(a || (() => {})),
						V = (0, d.E)(w.tabs),
						A = (0, i.useMemo)((() => ({
							orientation: v,
							activation: g,
							...w
						})), [v, g, w]),
						S = (0, f.z)((t => (E({
							type: 1,
							tab: t
						}), () => E({
							type: 2,
							tab: t
						})))),
						M = (0, f.z)((t => (E({
							type: 3,
							panel: t
						}), () => E({
							type: 4,
							panel: t
						})))),
						k = (0, f.z)((t => {
							B.current !== t && P.current(t), y || E({
								type: 0,
								index: t
							})
						})),
						B = (0, d.E)(y ? t.selectedIndex : w.selectedIndex),
						I = (0, i.useMemo)((() => ({
							registerTab: S,
							registerPanel: M,
							change: k
						})), []);
					(0, u.e)((() => {
						E({
							type: 0,
							index: null != h ? h : n
						})
					}), [h]), (0, u.e)((() => {
						if (void 0 === B.current || w.tabs.length <= 0) return;
						let t = (0, l.z2)(w.tabs, (t => t.current));
						t.some(((t, e) => w.tabs[e] !== t)) && k(t.indexOf(w.tabs[B.current]))
					}));
					let j = {
						ref: b
					};
					return i.createElement(x, null, i.createElement(R.Provider, {
						value: I
					}, i.createElement(C.Provider, {
						value: A
					}, A.tabs.length <= 0 && i.createElement(m, {
						onFocus: () => {
							var t, e;
							for (let n of V.current)
								if (0 === (null == (t = n.current) ? void 0 : t.tabIndex)) return null == (e = n.current) || e.focus(), !0;
							return !1
						}
					}), (0, o.sY)({
						ourProps: j,
						theirProps: p,
						slot: T,
						defaultTag: D,
						name: "Tabs"
					}))))
				})),
				O = (0, o.yV)((function(t, e) {
					let {
						orientation: n,
						selectedIndex: i
					} = M("Tab.List"), r = (0, c.T)(e);
					return (0, o.sY)({
						ourProps: {
							ref: r,
							role: "tablist",
							"aria-orientation": n
						},
						theirProps: t,
						slot: {
							selectedIndex: i
						},
						defaultTag: "div",
						name: "Tabs.List"
					})
				})),
				F = (0, o.yV)((function(t, e) {
					let {
						selectedIndex: n
					} = M("Tab.Panels"), r = (0, c.T)(e), s = (0, i.useMemo)((() => ({
						selectedIndex: n
					})), [n]);
					return (0, o.sY)({
						ourProps: {
							ref: r
						},
						theirProps: t,
						slot: s,
						defaultTag: "div",
						name: "Tabs.Panels"
					})
				})),
				U = (0, o.yV)((function(t, e) {
					var n, s, a, l;
					let h = (0, r.M)(),
						{
							id: d = `headlessui-tabs-panel-${h}`,
							tabIndex: m = 0,
							...f
						} = t,
						{
							selectedIndex: v,
							tabs: g,
							panels: y
						} = M("Tab.Panel"),
						x = k("Tab.Panel"),
						w = (0, i.useRef)(null),
						E = (0, c.T)(w, e);
					(0, u.e)((() => x.registerPanel(w)), [x, w]);
					let T = b("panels"),
						P = y.indexOf(w); - 1 === P && (P = T);
					let V = P === v,
						A = (0, i.useMemo)((() => ({
							selected: V
						})), [V]),
						S = {
							ref: E,
							id: d,
							role: "tabpanel",
							"aria-labelledby": null == (s = null == (n = g[P]) ? void 0 : n.current) ? void 0 : s.id,
							tabIndex: V ? m : -1
						};
					return V || null != (a = f.unmount) && !a || null != (l = f.static) && l ? (0, o.sY)({
						ourProps: S,
						theirProps: f,
						slot: A,
						defaultTag: "div",
						features: B,
						visible: V,
						name: "Tabs.Panel"
					}) : i.createElement(p._, {
						as: "span",
						...S
					})
				})),
				N = Object.assign(I, {
					Group: j,
					List: O,
					Panels: F,
					Panel: U
				})
		},
		3681: function(t, e, n) {
			"use strict";
			n.d(e, {
				M: function() {
					return v
				}
			});
			var i = n(7378),
				o = n(7596),
				r = n(4306);

			function s() {
				const t = (0, i.useRef)(!1);
				return (0, r.L)((() => (t.current = !0, () => {
					t.current = !1
				})), []), t
			}
			var a = n(7387),
				l = n(2308);
			class u extends i.Component {
				getSnapshotBeforeUpdate(t) {
					const e = this.props.childRef.current;
					if (e && t.isPresent && !this.props.isPresent) {
						const t = this.props.sizeRef.current;
						t.height = e.offsetHeight || 0, t.width = e.offsetWidth || 0, t.top = e.offsetTop, t.left = e.offsetLeft
					}
					return null
				}
				componentDidUpdate() {}
				render() {
					return this.props.children
				}
			}

			function c({
				children: t,
				isPresent: e
			}) {
				const n = (0, i.useId)(),
					o = (0, i.useRef)(null),
					r = (0, i.useRef)({
						width: 0,
						height: 0,
						top: 0,
						left: 0
					});
				return (0, i.useInsertionEffect)((() => {
					const {
						width: t,
						height: i,
						top: s,
						left: a
					} = r.current;
					if (e || !o.current || !t || !i) return;
					o.current.dataset.motionPopId = n;
					const l = document.createElement("style");
					return document.head.appendChild(l), l.sheet && l.sheet.insertRule(`\n          [data-motion-pop-id="${n}"] {\n            position: absolute !important;\n            width: ${t}px !important;\n            height: ${i}px !important;\n            top: ${s}px !important;\n            left: ${a}px !important;\n          }\n        `), () => {
						document.head.removeChild(l)
					}
				}), [e]), i.createElement(u, {
					isPresent: e,
					childRef: o,
					sizeRef: r
				}, i.cloneElement(t, {
					ref: o
				}))
			}
			const h = ({
				children: t,
				initial: e,
				isPresent: n,
				onExitComplete: o,
				custom: r,
				presenceAffectsLayout: s,
				mode: u
			}) => {
				const h = (0, l.h)(d),
					p = (0, i.useId)(),
					m = (0, i.useMemo)((() => ({
						id: p,
						initial: e,
						isPresent: n,
						custom: r,
						onExitComplete: t => {
							h.set(t, !0);
							for (const e of h.values())
								if (!e) return;
							o && o()
						},
						register: t => (h.set(t, !1), () => h.delete(t))
					})), s ? void 0 : [n]);
				return (0, i.useMemo)((() => {
					h.forEach(((t, e) => h.set(e, !1)))
				}), [n]), i.useEffect((() => {
					!n && !h.size && o && o()
				}), [n]), "popLayout" === u && (t = i.createElement(c, {
					isPresent: n
				}, t)), i.createElement(a.O.Provider, {
					value: m
				}, t)
			};

			function d() {
				return new Map
			}
			var p = n(3684),
				m = n(9929);
			const f = t => t.key || "";
			const v = ({
				children: t,
				custom: e,
				initial: n = !0,
				onExitComplete: a,
				exitBeforeEnter: l,
				presenceAffectsLayout: u = !0,
				mode: c = "sync"
			}) => {
				l && (c = "wait");
				let [d] = function() {
					const t = s(),
						[e, n] = (0, i.useState)(0),
						r = (0, i.useCallback)((() => {
							t.current && n(e + 1)
						}), [e]);
					return [(0, i.useCallback)((() => o.Z_.postRender(r)), [r]), e]
				}();
				const v = (0, i.useContext)(p.p).forceRender;
				v && (d = v);
				const g = s(),
					y = function(t) {
						const e = [];
						return i.Children.forEach(t, (t => {
							(0, i.isValidElement)(t) && e.push(t)
						})), e
					}(t);
				let x = y;
				const b = new Set,
					w = (0, i.useRef)(x),
					E = (0, i.useRef)(new Map).current,
					T = (0, i.useRef)(!0);
				if ((0, r.L)((() => {
						T.current = !1,
							function(t, e) {
								t.forEach((t => {
									const n = f(t);
									e.set(n, t)
								}))
							}(y, E), w.current = x
					})), (0, m.z)((() => {
						T.current = !0, E.clear(), b.clear()
					})), T.current) return i.createElement(i.Fragment, null, x.map((t => i.createElement(h, {
					key: f(t),
					isPresent: !0,
					initial: !!n && void 0,
					presenceAffectsLayout: u,
					mode: c
				}, t))));
				x = [...x];
				const P = w.current.map(f),
					V = y.map(f),
					A = P.length;
				for (let i = 0; i < A; i++) {
					const t = P[i]; - 1 === V.indexOf(t) && b.add(t)
				}
				return "wait" === c && b.size && (x = []), b.forEach((t => {
					if (-1 !== V.indexOf(t)) return;
					const n = E.get(t);
					if (!n) return;
					const o = P.indexOf(t);
					x.splice(o, 0, i.createElement(h, {
						key: f(n),
						isPresent: !1,
						onExitComplete: () => {
							E.delete(t), b.delete(t);
							const e = w.current.findIndex((e => e.key === t));
							if (w.current.splice(e, 1), !b.size) {
								if (w.current = y, !1 === g.current) return;
								d(), a && a()
							}
						},
						custom: e,
						presenceAffectsLayout: u,
						mode: c
					}, n))
				})), x = x.map((t => {
					const e = t.key;
					return b.has(e) ? t : i.createElement(h, {
						key: f(t),
						isPresent: !0,
						presenceAffectsLayout: u,
						mode: c
					}, t)
				})), i.createElement(i.Fragment, null, b.size ? x : x.map((t => (0, i.cloneElement)(t))))
			}
		},
		3684: function(t, e, n) {
			"use strict";
			n.d(e, {
				p: function() {
					return i
				}
			});
			const i = (0, n(7378).createContext)({})
		},
		7387: function(t, e, n) {
			"use strict";
			n.d(e, {
				O: function() {
					return i
				}
			});
			const i = (0, n(7378).createContext)(null)
		},
		5741: function(t, e, n) {
			"use strict";
			n.d(e, {
				w: function() {
					return i
				}
			});
			const i = {
				delta: 0,
				timestamp: 0
			}
		},
		7596: function(t, e, n) {
			"use strict";
			n.d(e, {
				qY: function() {
					return p
				},
				iW: function() {
					return m
				},
				Z_: function() {
					return d
				}
			});
			const i = 1 / 60 * 1e3,
				o = "undefined" !== typeof performance ? () => performance.now() : () => Date.now(),
				r = "undefined" !== typeof window ? t => window.requestAnimationFrame(t) : t => setTimeout((() => t(o())), i);
			var s = n(5741);
			let a = !0,
				l = !1,
				u = !1;
			const c = ["read", "update", "preRender", "render", "postRender"],
				h = c.reduce(((t, e) => (t[e] = function(t) {
					let e = [],
						n = [],
						i = 0,
						o = !1,
						r = !1;
					const s = new WeakSet,
						a = {
							schedule: (t, r = !1, a = !1) => {
								const l = a && o,
									u = l ? e : n;
								return r && s.add(t), -1 === u.indexOf(t) && (u.push(t), l && o && (i = e.length)), t
							},
							cancel: t => {
								const e = n.indexOf(t); - 1 !== e && n.splice(e, 1), s.delete(t)
							},
							process: l => {
								if (o) r = !0;
								else {
									if (o = !0, [e, n] = [n, e], n.length = 0, i = e.length, i)
										for (let n = 0; n < i; n++) {
											const i = e[n];
											i(l), s.has(i) && (a.schedule(i), t())
										}
									o = !1, r && (r = !1, a.process(l))
								}
							}
						};
					return a
				}((() => l = !0)), t)), {}),
				d = c.reduce(((t, e) => {
					const n = h[e];
					return t[e] = (t, e = !1, i = !1) => (l || g(), n.schedule(t, e, i)), t
				}), {}),
				p = c.reduce(((t, e) => (t[e] = h[e].cancel, t)), {}),
				m = c.reduce(((t, e) => (t[e] = () => h[e].process(s.w), t)), {}),
				f = t => h[t].process(s.w),
				v = t => {
					l = !1, s.w.delta = a ? i : Math.max(Math.min(t - s.w.timestamp, 40), 1), s.w.timestamp = t, u = !0, c.forEach(f), u = !1, l && (a = !1, r(v))
				},
				g = () => {
					l = !0, a = !0, u || r(v)
				}
		},
		5751: function(t, e, n) {
			"use strict";
			n.d(e, {
				E: function() {
					return Nr
				}
			});
			var i = n(7378);
			const o = (0, i.createContext)({
					transformPagePoint: t => t,
					isStatic: !1,
					reducedMotion: "never"
				}),
				r = (0, i.createContext)({});
			var s = n(7387),
				a = n(4306);
			const l = (0, i.createContext)({
				strict: !1
			});

			function u(t, e, n, u) {
				const c = (0, i.useContext)(r).visualElement,
					h = (0, i.useContext)(l),
					d = (0, i.useContext)(s.O),
					p = (0, i.useContext)(o).reducedMotion,
					m = (0, i.useRef)();
				u = u || h.renderer, !m.current && u && (m.current = u(t, {
					visualState: e,
					parent: c,
					props: n,
					presenceId: d ? d.id : void 0,
					blockInitialAnimation: !!d && !1 === d.initial,
					reducedMotionConfig: p
				}));
				const f = m.current;
				(0, a.L)((() => {
					f && f.render()
				}));
				return (window.HandoffAppearAnimations ? a.L : i.useEffect)((() => {
					f && f.animationState && f.animationState.animateChanges()
				})), f
			}

			function c(t) {
				return "object" === typeof t && Object.prototype.hasOwnProperty.call(t, "current")
			}

			function h(t) {
				return "string" === typeof t || Array.isArray(t)
			}

			function d(t) {
				return "object" === typeof t && "function" === typeof t.start
			}
			const p = ["initial", "animate", "exit", "whileHover", "whileDrag", "whileTap", "whileFocus", "whileInView"];

			function m(t) {
				return d(t.animate) || p.some((e => h(t[e])))
			}

			function f(t) {
				return Boolean(m(t) || t.variants)
			}

			function v(t) {
				const {
					initial: e,
					animate: n
				} = function(t, e) {
					if (m(t)) {
						const {
							initial: e,
							animate: n
						} = t;
						return {
							initial: !1 === e || h(e) ? e : void 0,
							animate: h(n) ? n : void 0
						}
					}
					return !1 !== t.inherit ? e : {}
				}(t, (0, i.useContext)(r));
				return (0, i.useMemo)((() => ({
					initial: e,
					animate: n
				})), [g(e), g(n)])
			}

			function g(t) {
				return Array.isArray(t) ? t.join(" ") : t
			}
			const y = t => ({
					isEnabled: e => t.some((t => !!e[t]))
				}),
				x = {
					measureLayout: y(["layout", "layoutId", "drag"]),
					animation: y(["animate", "exit", "variants", "whileHover", "whileTap", "whileFocus", "whileDrag", "whileInView"]),
					exit: y(["exit"]),
					drag: y(["drag", "dragControls"]),
					focus: y(["whileFocus"]),
					hover: y(["whileHover", "onHoverStart", "onHoverEnd"]),
					tap: y(["whileTap", "onTap", "onTapStart", "onTapCancel"]),
					pan: y(["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"]),
					inView: y(["whileInView", "onViewportEnter", "onViewportLeave"])
				};
			var b = n(6949),
				w = n(2308);
			const E = {
				hasAnimatedSinceResize: !0,
				hasEverUpdated: !1
			};
			let T = 1;
			var P = n(3684);
			class V extends i.Component {
				getSnapshotBeforeUpdate() {
					const {
						visualElement: t,
						props: e
					} = this.props;
					return t && t.setProps(e), null
				}
				componentDidUpdate() {}
				render() {
					return this.props.children
				}
			}
			const A = (0, i.createContext)({}),
				S = Symbol.for("motionComponentSymbol");

			function C({
				preloadedFeatures: t,
				createVisualElement: e,
				projectionNodeConstructor: n,
				useRender: s,
				useVisualState: a,
				Component: h
			}) {
				t && function(t) {
					for (const e in t) "projectionNodeConstructor" === e ? x.projectionNodeConstructor = t[e] : x[e].Component = t[e]
				}(t);
				const d = (0, i.forwardRef)((function(d, p) {
					const m = {
							...(0, i.useContext)(o),
							...d,
							layoutId: M(d)
						},
						{
							isStatic: f
						} = m;
					let g = null;
					const y = v(d),
						P = f ? void 0 : (0, w.h)((() => {
							if (E.hasEverUpdated) return T++
						})),
						S = a(d, f);
					if (!f && b.j) {
						y.visualElement = u(h, S, m, e);
						const o = (0, i.useContext)(l).strict,
							r = (0, i.useContext)(A);
						y.visualElement && (g = y.visualElement.loadFeatures(m, o, t, P, n || x.projectionNodeConstructor, r))
					}
					return i.createElement(V, {
						visualElement: y.visualElement,
						props: m
					}, g, i.createElement(r.Provider, {
						value: y
					}, s(h, d, P, function(t, e, n) {
						return (0, i.useCallback)((i => {
							i && t.mount && t.mount(i), e && (i ? e.mount(i) : e.unmount()), n && ("function" === typeof n ? n(i) : c(n) && (n.current = i))
						}), [e])
					}(S, y.visualElement, p), S, f, y.visualElement)))
				}));
				return d[S] = h, d
			}

			function M({
				layoutId: t
			}) {
				const e = (0, i.useContext)(P.p).id;
				return e && void 0 !== t ? e + "-" + t : t
			}

			function R(t) {
				function e(e, n = {}) {
					return C(t(e, n))
				}
				if ("undefined" === typeof Proxy) return e;
				const n = new Map;
				return new Proxy(e, {
					get: (t, i) => (n.has(i) || n.set(i, e(i)), n.get(i))
				})
			}
			const k = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];

			function L(t) {
				return "string" === typeof t && !t.includes("-") && !!(k.indexOf(t) > -1 || /[A-Z]/.test(t))
			}
			const D = {};
			const B = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"],
				I = new Set(B);

			function j(t, {
				layout: e,
				layoutId: n
			}) {
				return I.has(t) || t.startsWith("origin") || (e || void 0 !== n) && (!!D[t] || "opacity" === t)
			}
			const O = t => !!(null === t || void 0 === t ? void 0 : t.getVelocity),
				F = {
					x: "translateX",
					y: "translateY",
					z: "translateZ",
					transformPerspective: "perspective"
				},
				U = (t, e) => B.indexOf(t) - B.indexOf(e);

			function N(t) {
				return t.startsWith("--")
			}
			const z = (t, e) => e && "number" === typeof t ? e.transform(t) : t,
				W = (t, e, n) => Math.min(Math.max(n, t), e),
				$ = {
					test: t => "number" === typeof t,
					parse: parseFloat,
					transform: t => t
				},
				Y = {
					...$,
					transform: t => W(0, 1, t)
				},
				_ = {
					...$,
					default: 1
				},
				H = t => Math.round(1e5 * t) / 1e5,
				Z = /(-)?([\d]*\.?[\d])+/g,
				q = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi,
				X = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;

			function G(t) {
				return "string" === typeof t
			}
			const K = t => ({
					test: e => G(e) && e.endsWith(t) && 1 === e.split(" ").length,
					parse: parseFloat,
					transform: e => `${e}${t}`
				}),
				J = K("deg"),
				Q = K("%"),
				tt = K("px"),
				et = K("vh"),
				nt = K("vw"),
				it = {
					...Q,
					parse: t => Q.parse(t) / 100,
					transform: t => Q.transform(100 * t)
				},
				ot = {
					...$,
					transform: Math.round
				},
				rt = {
					borderWidth: tt,
					borderTopWidth: tt,
					borderRightWidth: tt,
					borderBottomWidth: tt,
					borderLeftWidth: tt,
					borderRadius: tt,
					radius: tt,
					borderTopLeftRadius: tt,
					borderTopRightRadius: tt,
					borderBottomRightRadius: tt,
					borderBottomLeftRadius: tt,
					width: tt,
					maxWidth: tt,
					height: tt,
					maxHeight: tt,
					size: tt,
					top: tt,
					right: tt,
					bottom: tt,
					left: tt,
					padding: tt,
					paddingTop: tt,
					paddingRight: tt,
					paddingBottom: tt,
					paddingLeft: tt,
					margin: tt,
					marginTop: tt,
					marginRight: tt,
					marginBottom: tt,
					marginLeft: tt,
					rotate: J,
					rotateX: J,
					rotateY: J,
					rotateZ: J,
					scale: _,
					scaleX: _,
					scaleY: _,
					scaleZ: _,
					skew: J,
					skewX: J,
					skewY: J,
					distance: tt,
					translateX: tt,
					translateY: tt,
					translateZ: tt,
					x: tt,
					y: tt,
					z: tt,
					perspective: tt,
					transformPerspective: tt,
					opacity: Y,
					originX: it,
					originY: it,
					originZ: tt,
					zIndex: ot,
					fillOpacity: Y,
					strokeOpacity: Y,
					numOctaves: ot
				};

			function st(t, e, n, i) {
				const {
					style: o,
					vars: r,
					transform: s,
					transformKeys: a,
					transformOrigin: l
				} = t;
				a.length = 0;
				let u = !1,
					c = !1,
					h = !0;
				for (const d in e) {
					const t = e[d];
					if (N(d)) {
						r[d] = t;
						continue
					}
					const n = rt[d],
						i = z(t, n);
					if (I.has(d)) {
						if (u = !0, s[d] = i, a.push(d), !h) continue;
						t !== (n.default || 0) && (h = !1)
					} else d.startsWith("origin") ? (c = !0, l[d] = i) : o[d] = i
				}
				if (e.transform || (u || i ? o.transform = function({
						transform: t,
						transformKeys: e
					}, {
						enableHardwareAcceleration: n = !0,
						allowTransformNone: i = !0
					}, o, r) {
						let s = "";
						e.sort(U);
						for (const a of e) s += `${F[a]||a}(${t[a]}) `;
						return n && !t.z && (s += "translateZ(0)"), s = s.trim(), r ? s = r(t, o ? "" : s) : i && o && (s = "none"), s
					}(t, n, h, i) : o.transform && (o.transform = "none")), c) {
					const {
						originX: t = "50%",
						originY: e = "50%",
						originZ: n = 0
					} = l;
					o.transformOrigin = `${t} ${e} ${n}`
				}
			}
			const at = () => ({
				style: {},
				transform: {},
				transformKeys: [],
				transformOrigin: {},
				vars: {}
			});

			function lt(t, e, n) {
				for (const i in e) O(e[i]) || j(i, n) || (t[i] = e[i])
			}

			function ut(t, e, n) {
				const o = {};
				return lt(o, t.style || {}, t), Object.assign(o, function({
					transformTemplate: t
				}, e, n) {
					return (0, i.useMemo)((() => {
						const i = {
							style: {},
							transform: {},
							transformKeys: [],
							transformOrigin: {},
							vars: {}
						};
						return st(i, e, {
							enableHardwareAcceleration: !n
						}, t), Object.assign({}, i.vars, i.style)
					}), [e])
				}(t, e, n)), t.transformValues ? t.transformValues(o) : o
			}

			function ct(t, e, n) {
				const i = {},
					o = ut(t, e, n);
				return t.drag && !1 !== t.dragListener && (i.draggable = !1, o.userSelect = o.WebkitUserSelect = o.WebkitTouchCallout = "none", o.touchAction = !0 === t.drag ? "none" : "pan-" + ("x" === t.drag ? "y" : "x")), i.style = o, i
			}
			const ht = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "transformValues", "custom", "inherit", "onLayoutAnimationStart", "onLayoutAnimationComplete", "onLayoutMeasure", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "viewport"]);

			function dt(t) {
				return t.startsWith("while") || t.startsWith("drag") && "draggable" !== t || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || ht.has(t)
			}
			let pt = t => !dt(t);
			try {
				(mt = require("@emotion/is-prop-valid").default) && (pt = t => t.startsWith("on") ? !dt(t) : mt(t))
			} catch (zr) {}
			var mt;

			function ft(t, e, n) {
				return "string" === typeof t ? t : tt.transform(e + n * t)
			}
			const vt = {
					offset: "stroke-dashoffset",
					array: "stroke-dasharray"
				},
				gt = {
					offset: "strokeDashoffset",
					array: "strokeDasharray"
				};

			function yt(t, {
				attrX: e,
				attrY: n,
				originX: i,
				originY: o,
				pathLength: r,
				pathSpacing: s = 1,
				pathOffset: a = 0,
				...l
			}, u, c, h) {
				if (st(t, l, u, h), c) return void(t.style.viewBox && (t.attrs.viewBox = t.style.viewBox));
				t.attrs = t.style, t.style = {};
				const {
					attrs: d,
					style: p,
					dimensions: m
				} = t;
				d.transform && (m && (p.transform = d.transform), delete d.transform), m && (void 0 !== i || void 0 !== o || p.transform) && (p.transformOrigin = function(t, e, n) {
					return `${ft(e,t.x,t.width)} ${ft(n,t.y,t.height)}`
				}(m, void 0 !== i ? i : .5, void 0 !== o ? o : .5)), void 0 !== e && (d.x = e), void 0 !== n && (d.y = n), void 0 !== r && function(t, e, n = 1, i = 0, o = !0) {
					t.pathLength = 1;
					const r = o ? vt : gt;
					t[r.offset] = tt.transform(-i);
					const s = tt.transform(e),
						a = tt.transform(n);
					t[r.array] = `${s} ${a}`
				}(d, r, s, a, !1)
			}
			const xt = () => ({
					style: {},
					transform: {},
					transformKeys: [],
					transformOrigin: {},
					vars: {},
					attrs: {}
				}),
				bt = t => "string" === typeof t && "svg" === t.toLowerCase();

			function wt(t, e, n, o) {
				const r = (0, i.useMemo)((() => {
					const n = {
						style: {},
						transform: {},
						transformKeys: [],
						transformOrigin: {},
						vars: {},
						attrs: {}
					};
					return yt(n, e, {
						enableHardwareAcceleration: !1
					}, bt(o), t.transformTemplate), {
						...n.attrs,
						style: {
							...n.style
						}
					}
				}), [e]);
				if (t.style) {
					const e = {};
					lt(e, t.style, t), r.style = {
						...e,
						...r.style
					}
				}
				return r
			}

			function Et(t = !1) {
				return (e, n, o, r, {
					latestValues: s
				}, a) => {
					const l = (L(e) ? wt : ct)(n, s, a, e),
						u = function(t, e, n) {
							const i = {};
							for (const o in t) "values" === o && "object" === typeof t.values || (pt(o) || !0 === n && dt(o) || !e && !dt(o) || t.draggable && o.startsWith("onDrag")) && (i[o] = t[o]);
							return i
						}(n, "string" === typeof e, t),
						c = {
							...u,
							...l,
							ref: r
						},
						{
							children: h
						} = n,
						d = (0, i.useMemo)((() => O(h) ? h.get() : h), [h]);
					return o && (c["data-projection-id"] = o), (0, i.createElement)(e, {
						...c,
						children: d
					})
				}
			}
			const Tt = t => t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();

			function Pt(t, {
				style: e,
				vars: n
			}, i, o) {
				Object.assign(t.style, e, o && o.getProjectionStyles(i));
				for (const r in n) t.style.setProperty(r, n[r])
			}
			const Vt = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);

			function At(t, e, n, i) {
				Pt(t, e, void 0, i);
				for (const o in e.attrs) t.setAttribute(Vt.has(o) ? o : Tt(o), e.attrs[o])
			}

			function St(t, e) {
				const {
					style: n
				} = t, i = {};
				for (const o in n)(O(n[o]) || e.style && O(e.style[o]) || j(o, t)) && (i[o] = n[o]);
				return i
			}

			function Ct(t, e) {
				const n = St(t, e);
				for (const i in t)
					if (O(t[i]) || O(e[i])) {
						n["x" === i || "y" === i ? "attr" + i.toUpperCase() : i] = t[i]
					} return n
			}

			function Mt(t, e, n, i = {}, o = {}) {
				return "function" === typeof e && (e = e(void 0 !== n ? n : t.custom, i, o)), "string" === typeof e && (e = t.variants && t.variants[e]), "function" === typeof e && (e = e(void 0 !== n ? n : t.custom, i, o)), e
			}
			const Rt = t => Array.isArray(t);

			function kt(t) {
				const e = O(t) ? t.get() : t;
				return n = e, Boolean(n && "object" === typeof n && n.mix && n.toValue) ? e.toValue() : e;
				var n
			}
			const Lt = t => (e, n) => {
				const o = (0, i.useContext)(r),
					a = (0, i.useContext)(s.O),
					l = () => function({
						scrapeMotionValuesFromProps: t,
						createRenderState: e,
						onMount: n
					}, i, o, r) {
						const s = {
							latestValues: Dt(i, o, r, t),
							renderState: e()
						};
						return n && (s.mount = t => n(i, t, s)), s
					}(t, e, o, a);
				return n ? l() : (0, w.h)(l)
			};

			function Dt(t, e, n, i) {
				const o = {},
					r = i(t, {});
				for (const d in r) o[d] = kt(r[d]);
				let {
					initial: s,
					animate: a
				} = t;
				const l = m(t),
					u = f(t);
				e && u && !l && !1 !== t.inherit && (void 0 === s && (s = e.initial), void 0 === a && (a = e.animate));
				let c = !!n && !1 === n.initial;
				c = c || !1 === s;
				const h = c ? a : s;
				if (h && "boolean" !== typeof h && !d(h)) {
					(Array.isArray(h) ? h : [h]).forEach((e => {
						const n = Mt(t, e);
						if (!n) return;
						const {
							transitionEnd: i,
							transition: r,
							...s
						} = n;
						for (const t in s) {
							let e = s[t];
							if (Array.isArray(e)) {
								e = e[c ? e.length - 1 : 0]
							}
							null !== e && (o[t] = e)
						}
						for (const t in i) o[t] = i[t]
					}))
				}
				return o
			}
			const Bt = {
					useVisualState: Lt({
						scrapeMotionValuesFromProps: Ct,
						createRenderState: xt,
						onMount: (t, e, {
							renderState: n,
							latestValues: i
						}) => {
							try {
								n.dimensions = "function" === typeof e.getBBox ? e.getBBox() : e.getBoundingClientRect()
							} catch (o) {
								n.dimensions = {
									x: 0,
									y: 0,
									width: 0,
									height: 0
								}
							}
							yt(n, i, {
								enableHardwareAcceleration: !1
							}, bt(e.tagName), t.transformTemplate), At(e, n)
						}
					})
				},
				It = {
					useVisualState: Lt({
						scrapeMotionValuesFromProps: St,
						createRenderState: at
					})
				};
			var jt;

			function Ot(t, e, n, i = {
				passive: !0
			}) {
				return t.addEventListener(e, n, i), () => t.removeEventListener(e, n)
			}

			function Ft(t, e, n, o) {
				(0, i.useEffect)((() => {
					const i = t.current;
					if (n && i) return Ot(i, e, n, o)
				}), [t, e, n, o])
			}! function(t) {
				t.Animate = "animate", t.Hover = "whileHover", t.Tap = "whileTap", t.Drag = "whileDrag", t.Focus = "whileFocus", t.InView = "whileInView", t.Exit = "exit"
			}(jt || (jt = {}));
			const Ut = t => "mouse" === t.pointerType ? "number" !== typeof t.button || t.button <= 0 : !1 !== t.isPrimary;

			function Nt(t, e = "page") {
				return {
					point: {
						x: t[e + "X"],
						y: t[e + "Y"]
					}
				}
			}
			const zt = t => e => Ut(e) && t(e, Nt(e));

			function Wt(t, e, n, i) {
				return Ot(t, e, zt(n), i)
			}

			function $t(t, e, n, i) {
				return Ft(t, e, n && zt(n), i)
			}

			function Yt(t) {
				let e = null;
				return () => {
					const n = () => {
						e = null
					};
					return null === e && (e = t, n)
				}
			}
			const _t = Yt("dragHorizontal"),
				Ht = Yt("dragVertical");

			function Zt(t) {
				let e = !1;
				if ("y" === t) e = Ht();
				else if ("x" === t) e = _t();
				else {
					const t = _t(),
						n = Ht();
					t && n ? e = () => {
						t(), n()
					} : (t && t(), n && n())
				}
				return e
			}

			function qt() {
				const t = Zt(!0);
				return !t || (t(), !1)
			}

			function Xt(t, e, n, i) {
				return (o, r) => {
					"touch" === o.type || qt() || (n && t.animationState && t.animationState.setActive(jt.Hover, e), i && i(o, r))
				}
			}
			const Gt = (t, e) => !!e && (t === e || Gt(t, e.parentElement));
			var Kt = n(9929);
			const Jt = (t, e) => n => e(t(n)),
				Qt = (...t) => t.reduce(Jt);
			const te = new WeakMap,
				ee = new WeakMap,
				ne = t => {
					const e = te.get(t.target);
					e && e(t)
				},
				ie = t => {
					t.forEach(ne)
				};

			function oe(t, e, n) {
				const i = function({
					root: t,
					...e
				}) {
					const n = t || document;
					ee.has(n) || ee.set(n, {});
					const i = ee.get(n),
						o = JSON.stringify(e);
					return i[o] || (i[o] = new IntersectionObserver(ie, {
						root: t,
						...e
					})), i[o]
				}(e);
				return te.set(t, n), i.observe(t), () => {
					te.delete(t), i.unobserve(t)
				}
			}
			const re = {
				some: 0,
				all: 1
			};

			function se(t, e, n, {
				root: o,
				margin: r,
				amount: s = "some",
				once: a
			}) {
				(0, i.useEffect)((() => {
					if (!t || !n.current) return;
					const i = {
						root: null === o || void 0 === o ? void 0 : o.current,
						rootMargin: r,
						threshold: "number" === typeof s ? s : re[s]
					};
					return oe(n.current, i, (t => {
						const {
							isIntersecting: i
						} = t;
						if (e.isInView === i) return;
						if (e.isInView = i, a && !i && e.hasEnteredView) return;
						i && (e.hasEnteredView = !0), n.animationState && n.animationState.setActive(jt.InView, i);
						const o = n.getProps(),
							r = i ? o.onViewportEnter : o.onViewportLeave;
						r && r(t)
					}))
				}), [t, o, r, s])
			}

			function ae(t, e, n, {
				fallback: o = !0
			}) {
				(0, i.useEffect)((() => {
					t && o && requestAnimationFrame((() => {
						e.hasEnteredView = !0;
						const {
							onViewportEnter: t
						} = n.getProps();
						t && t(null), n.animationState && n.animationState.setActive(jt.InView, !0)
					}))
				}), [t])
			}
			const le = t => e => (t(e), null),
				ue = {
					inView: le((function({
						visualElement: t,
						whileInView: e,
						onViewportEnter: n,
						onViewportLeave: o,
						viewport: r = {}
					}) {
						const s = (0, i.useRef)({
							hasEnteredView: !1,
							isInView: !1
						});
						let a = Boolean(e || n || o);
						r.once && s.current.hasEnteredView && (a = !1), ("undefined" === typeof IntersectionObserver ? ae : se)(a, s.current, t, r)
					})),
					tap: le((function({
						onTap: t,
						onTapStart: e,
						onTapCancel: n,
						whileTap: o,
						visualElement: r,
						...s
					}) {
						const a = t || e || n || o,
							l = (0, i.useRef)(!1),
							u = (0, i.useRef)(null),
							c = {
								passive: !(e || t || n || s.onPointerDown)
							};

						function h() {
							u.current && u.current(), u.current = null
						}

						function d() {
							h(), l.current = !1;
							return r.getProps().whileTap && r.animationState && r.animationState.setActive(jt.Tap, !1), !qt()
						}

						function p(t, e) {
							var n, i, o, s;
							d() && (Gt(r.current, t.target) ? null === (s = (o = r.getProps()).onTap) || void 0 === s || s.call(o, t, e) : null === (i = (n = r.getProps()).onTapCancel) || void 0 === i || i.call(n, t, e))
						}

						function m(t, e) {
							var n, i;
							d() && (null === (i = (n = r.getProps()).onTapCancel) || void 0 === i || i.call(n, t, e))
						}
						const f = (0, i.useCallback)(((t, e) => {
							var n;
							if (h(), l.current) return;
							l.current = !0, u.current = Qt(Wt(window, "pointerup", p, c), Wt(window, "pointercancel", m, c));
							const i = r.getProps();
							i.whileTap && r.animationState && r.animationState.setActive(jt.Tap, !0), null === (n = i.onTapStart) || void 0 === n || n.call(i, t, e)
						}), [Boolean(e), r]);
						$t(r, "pointerdown", a ? f : void 0, c), (0, Kt.z)(h)
					})),
					focus: le((function({
						whileFocus: t,
						visualElement: e
					}) {
						const {
							animationState: n
						} = e, o = (0, i.useCallback)((() => {
							n && n.setActive(jt.Focus, !0)
						}), [n]), r = (0, i.useCallback)((() => {
							n && n.setActive(jt.Focus, !1)
						}), [n]);
						Ft(e, "focus", t ? o : void 0), Ft(e, "blur", t ? r : void 0)
					})),
					hover: le((function({
						onHoverStart: t,
						onHoverEnd: e,
						whileHover: n,
						visualElement: o
					}) {
						$t(o, "pointerenter", (0, i.useMemo)((() => t || n ? Xt(o, !0, Boolean(n), t) : void 0), [t, Boolean(n), o]), {
							passive: !t
						}), $t(o, "pointerleave", (0, i.useMemo)((() => e || n ? Xt(o, !1, Boolean(n), e) : void 0), [t, Boolean(n), o]), {
							passive: !e
						})
					}))
				};

			function ce() {
				const t = (0, i.useContext)(s.O);
				if (null === t) return [!0, null];
				const {
					isPresent: e,
					onExitComplete: n,
					register: o
				} = t, r = (0, i.useId)();
				(0, i.useEffect)((() => o(r)), []);
				return !e && n ? [!1, () => n && n(r)] : [!0]
			}

			function he(t, e) {
				if (!Array.isArray(e)) return !1;
				const n = e.length;
				if (n !== t.length) return !1;
				for (let i = 0; i < n; i++)
					if (e[i] !== t[i]) return !1;
				return !0
			}
			const de = t => /^0[^.\s]+$/.test(t);
			var pe = n(5741),
				me = n(7596);

			function fe(t, e) {
				-1 === t.indexOf(e) && t.push(e)
			}

			function ve(t, e) {
				const n = t.indexOf(e);
				n > -1 && t.splice(n, 1)
			}
			class ge {
				constructor() {
					this.subscriptions = []
				}
				add(t) {
					return fe(this.subscriptions, t), () => ve(this.subscriptions, t)
				}
				notify(t, e, n) {
					const i = this.subscriptions.length;
					if (i)
						if (1 === i) this.subscriptions[0](t, e, n);
						else
							for (let o = 0; o < i; o++) {
								const i = this.subscriptions[o];
								i && i(t, e, n)
							}
				}
				getSize() {
					return this.subscriptions.length
				}
				clear() {
					this.subscriptions.length = 0
				}
			}

			function ye(t, e) {
				return e ? t * (1e3 / e) : 0
			}
			class xe {
				constructor(t, e = {}) {
					var n;
					this.version = "8.5.5", this.timeDelta = 0, this.lastUpdated = 0, this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (t, e = !0) => {
						this.prev = this.current, this.current = t;
						const {
							delta: n,
							timestamp: i
						} = pe.w;
						this.lastUpdated !== i && (this.timeDelta = n, this.lastUpdated = i, me.Z_.postRender(this.scheduleVelocityCheck)), this.prev !== this.current && this.events.change && this.events.change.notify(this.current), this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()), e && this.events.renderRequest && this.events.renderRequest.notify(this.current)
					}, this.scheduleVelocityCheck = () => me.Z_.postRender(this.velocityCheck), this.velocityCheck = ({
						timestamp: t
					}) => {
						t !== this.lastUpdated && (this.prev = this.current, this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()))
					}, this.hasAnimated = !1, this.prev = this.current = t, this.canTrackVelocity = (n = this.current, !isNaN(parseFloat(n))), this.owner = e.owner
				}
				onChange(t) {
					return this.on("change", t)
				}
				on(t, e) {
					this.events[t] || (this.events[t] = new ge);
					const n = this.events[t].add(e);
					return "change" === t ? () => {
						n(), me.Z_.read((() => {
							this.events.change.getSize() || this.stop()
						}))
					} : n
				}
				clearListeners() {
					for (const t in this.events) this.events[t].clear()
				}
				attach(t, e) {
					this.passiveEffect = t, this.stopPassiveEffect = e
				}
				set(t, e = !0) {
					e && this.passiveEffect ? this.passiveEffect(t, this.updateAndNotify) : this.updateAndNotify(t, e)
				}
				setWithVelocity(t, e, n) {
					this.set(e), this.prev = t, this.timeDelta = n
				}
				jump(t) {
					this.updateAndNotify(t), this.prev = t, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
				}
				get() {
					return this.current
				}
				getPrevious() {
					return this.prev
				}
				getVelocity() {
					return this.canTrackVelocity ? ye(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0
				}
				start(t) {
					return this.stop(), new Promise((e => {
						this.hasAnimated = !0, this.animation = t(e) || null, this.events.animationStart && this.events.animationStart.notify()
					})).then((() => {
						this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation()
					}))
				}
				stop() {
					this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation()
				}
				isAnimating() {
					return !!this.animation
				}
				clearAnimation() {
					this.animation = null
				}
				destroy() {
					this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
				}
			}

			function be(t, e) {
				return new xe(t, e)
			}
			const we = (t, e) => n => Boolean(G(n) && X.test(n) && n.startsWith(t) || e && Object.prototype.hasOwnProperty.call(n, e)),
				Ee = (t, e, n) => i => {
					if (!G(i)) return i;
					const [o, r, s, a] = i.match(Z);
					return {
						[t]: parseFloat(o),
						[e]: parseFloat(r),
						[n]: parseFloat(s),
						alpha: void 0 !== a ? parseFloat(a) : 1
					}
				},
				Te = {
					...$,
					transform: t => Math.round((t => W(0, 255, t))(t))
				},
				Pe = {
					test: we("rgb", "red"),
					parse: Ee("red", "green", "blue"),
					transform: ({
						red: t,
						green: e,
						blue: n,
						alpha: i = 1
					}) => "rgba(" + Te.transform(t) + ", " + Te.transform(e) + ", " + Te.transform(n) + ", " + H(Y.transform(i)) + ")"
				};
			const Ve = {
					test: we("#"),
					parse: function(t) {
						let e = "",
							n = "",
							i = "",
							o = "";
						return t.length > 5 ? (e = t.substring(1, 3), n = t.substring(3, 5), i = t.substring(5, 7), o = t.substring(7, 9)) : (e = t.substring(1, 2), n = t.substring(2, 3), i = t.substring(3, 4), o = t.substring(4, 5), e += e, n += n, i += i, o += o), {
							red: parseInt(e, 16),
							green: parseInt(n, 16),
							blue: parseInt(i, 16),
							alpha: o ? parseInt(o, 16) / 255 : 1
						}
					},
					transform: Pe.transform
				},
				Ae = {
					test: we("hsl", "hue"),
					parse: Ee("hue", "saturation", "lightness"),
					transform: ({
						hue: t,
						saturation: e,
						lightness: n,
						alpha: i = 1
					}) => "hsla(" + Math.round(t) + ", " + Q.transform(H(e)) + ", " + Q.transform(H(n)) + ", " + H(Y.transform(i)) + ")"
				},
				Se = {
					test: t => Pe.test(t) || Ve.test(t) || Ae.test(t),
					parse: t => Pe.test(t) ? Pe.parse(t) : Ae.test(t) ? Ae.parse(t) : Ve.parse(t),
					transform: t => G(t) ? t : t.hasOwnProperty("red") ? Pe.transform(t) : Ae.transform(t)
				},
				Ce = "${c}",
				Me = "${n}";

			function Re(t) {
				"number" === typeof t && (t = `${t}`);
				const e = [];
				let n = 0,
					i = 0;
				const o = t.match(q);
				o && (n = o.length, t = t.replace(q, Ce), e.push(...o.map(Se.parse)));
				const r = t.match(Z);
				return r && (i = r.length, t = t.replace(Z, Me), e.push(...r.map($.parse))), {
					values: e,
					numColors: n,
					numNumbers: i,
					tokenised: t
				}
			}

			function ke(t) {
				return Re(t).values
			}

			function Le(t) {
				const {
					values: e,
					numColors: n,
					tokenised: i
				} = Re(t), o = e.length;
				return t => {
					let e = i;
					for (let i = 0; i < o; i++) e = e.replace(i < n ? Ce : Me, i < n ? Se.transform(t[i]) : H(t[i]));
					return e
				}
			}
			const De = t => "number" === typeof t ? 0 : t;
			const Be = {
					test: function(t) {
						var e, n;
						return isNaN(t) && G(t) && ((null === (e = t.match(Z)) || void 0 === e ? void 0 : e.length) || 0) + ((null === (n = t.match(q)) || void 0 === n ? void 0 : n.length) || 0) > 0
					},
					parse: ke,
					createTransformer: Le,
					getAnimatableNone: function(t) {
						const e = ke(t);
						return Le(t)(e.map(De))
					}
				},
				Ie = new Set(["brightness", "contrast", "saturate", "opacity"]);

			function je(t) {
				const [e, n] = t.slice(0, -1).split("(");
				if ("drop-shadow" === e) return t;
				const [i] = n.match(Z) || [];
				if (!i) return t;
				const o = n.replace(i, "");
				let r = Ie.has(e) ? 1 : 0;
				return i !== n && (r *= 100), e + "(" + r + o + ")"
			}
			const Oe = /([a-z-]*)\(.*?\)/g,
				Fe = {
					...Be,
					getAnimatableNone: t => {
						const e = t.match(Oe);
						return e ? e.map(je).join(" ") : t
					}
				},
				Ue = {
					...rt,
					color: Se,
					backgroundColor: Se,
					outlineColor: Se,
					fill: Se,
					stroke: Se,
					borderColor: Se,
					borderTopColor: Se,
					borderRightColor: Se,
					borderBottomColor: Se,
					borderLeftColor: Se,
					filter: Fe,
					WebkitFilter: Fe
				},
				Ne = t => Ue[t];

			function ze(t, e) {
				var n;
				let i = Ne(t);
				return i !== Fe && (i = Be), null === (n = i.getAnimatableNone) || void 0 === n ? void 0 : n.call(i, e)
			}
			const We = t => e => e.test(t),
				$e = [$, tt, Q, J, nt, et, {
					test: t => "auto" === t,
					parse: t => t
				}],
				Ye = t => $e.find(We(t)),
				_e = [...$e, Se, Be],
				He = t => _e.find(We(t));

			function Ze(t, e, n) {
				const i = t.getProps();
				return Mt(i, e, void 0 !== n ? n : i.custom, function(t) {
					const e = {};
					return t.values.forEach(((t, n) => e[n] = t.get())), e
				}(t), function(t) {
					const e = {};
					return t.values.forEach(((t, n) => e[n] = t.getVelocity())), e
				}(t))
			}

			function qe(t, e, n) {
				t.hasValue(e) ? t.getValue(e).set(n) : t.addValue(e, be(n))
			}

			function Xe(t, e) {
				const n = Ze(t, e);
				let {
					transitionEnd: i = {},
					transition: o = {},
					...r
				} = n ? t.makeTargetAnimatable(n, !1) : {};
				r = {
					...r,
					...i
				};
				for (const a in r) {
					qe(t, a, (s = r[a], Rt(s) ? s[s.length - 1] || 0 : s))
				}
				var s
			}

			function Ge(t, e) {
				if (!e) return;
				return (e[t] || e.default || e).from
			}

			function Ke(t) {
				return Boolean(O(t) && t.add)
			}
			const Je = "data-" + Tt("framerAppearId");
			const Qe = t => 1e3 * t,
				tn = !1,
				en = t => e => e <= .5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2,
				nn = t => e => 1 - t(1 - e),
				on = t => t * t,
				rn = nn(on),
				sn = en(on),
				an = (t, e, n) => -n * t + n * e + t;

			function ln(t, e, n) {
				return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t
			}
			const un = (t, e, n) => {
					const i = t * t;
					return Math.sqrt(Math.max(0, n * (e * e - i) + i))
				},
				cn = [Ve, Pe, Ae];

			function hn(t) {
				const e = (n = t, cn.find((t => t.test(n))));
				var n;
				Boolean(e);
				let i = e.parse(t);
				return e === Ae && (i = function({
					hue: t,
					saturation: e,
					lightness: n,
					alpha: i
				}) {
					t /= 360, n /= 100;
					let o = 0,
						r = 0,
						s = 0;
					if (e /= 100) {
						const i = n < .5 ? n * (1 + e) : n + e - n * e,
							a = 2 * n - i;
						o = ln(a, i, t + 1 / 3), r = ln(a, i, t), s = ln(a, i, t - 1 / 3)
					} else o = r = s = n;
					return {
						red: Math.round(255 * o),
						green: Math.round(255 * r),
						blue: Math.round(255 * s),
						alpha: i
					}
				}(i)), i
			}
			const dn = (t, e) => {
				const n = hn(t),
					i = hn(e),
					o = {
						...n
					};
				return t => (o.red = un(n.red, i.red, t), o.green = un(n.green, i.green, t), o.blue = un(n.blue, i.blue, t), o.alpha = an(n.alpha, i.alpha, t), Pe.transform(o))
			};

			function pn(t, e) {
				return "number" === typeof t ? n => an(t, e, n) : Se.test(t) ? dn(t, e) : vn(t, e)
			}
			const mn = (t, e) => {
					const n = [...t],
						i = n.length,
						o = t.map(((t, n) => pn(t, e[n])));
					return t => {
						for (let e = 0; e < i; e++) n[e] = o[e](t);
						return n
					}
				},
				fn = (t, e) => {
					const n = {
							...t,
							...e
						},
						i = {};
					for (const o in n) void 0 !== t[o] && void 0 !== e[o] && (i[o] = pn(t[o], e[o]));
					return t => {
						for (const e in i) n[e] = i[e](t);
						return n
					}
				},
				vn = (t, e) => {
					const n = Be.createTransformer(e),
						i = Re(t),
						o = Re(e);
					return i.numColors === o.numColors && i.numNumbers >= o.numNumbers ? Qt(mn(i.values, o.values), n) : n => `${n>0?e:t}`
				},
				gn = (t, e, n) => {
					const i = e - t;
					return 0 === i ? 1 : (n - t) / i
				},
				yn = (t, e) => n => an(t, e, n);

			function xn(t, e, n) {
				const i = [],
					o = n || ("number" === typeof(r = t[0]) ? yn : "string" === typeof r ? Se.test(r) ? dn : vn : Array.isArray(r) ? mn : "object" === typeof r ? fn : yn);
				var r;
				const s = t.length - 1;
				for (let a = 0; a < s; a++) {
					let n = o(t[a], t[a + 1]);
					if (e) {
						const t = Array.isArray(e) ? e[a] : e;
						n = Qt(t, n)
					}
					i.push(n)
				}
				return i
			}

			function bn(t, e, {
				clamp: n = !0,
				ease: i,
				mixer: o
			} = {}) {
				const r = t.length;
				e.length, !i || !Array.isArray(i) || i.length, t[0] > t[r - 1] && (t = [...t].reverse(), e = [...e].reverse());
				const s = xn(e, i, o),
					a = s.length,
					l = e => {
						let n = 0;
						if (a > 1)
							for (; n < t.length - 2 && !(e < t[n + 1]); n++);
						const i = gn(t[n], t[n + 1], e);
						return s[n](i)
					};
				return n ? e => l(W(t[0], t[r - 1], e)) : l
			}
			const wn = t => t,
				En = (t, e, n) => (((1 - 3 * n + 3 * e) * t + (3 * n - 6 * e)) * t + 3 * e) * t;

			function Tn(t, e, n, i) {
				if (t === e && n === i) return wn;
				const o = e => function(t, e, n, i, o) {
					let r, s, a = 0;
					do {
						s = e + (n - e) / 2, r = En(s, i, o) - t, r > 0 ? n = s : e = s
					} while (Math.abs(r) > 1e-7 && ++a < 12);
					return s
				}(e, 0, 1, t, n);
				return t => 0 === t || 1 === t ? t : En(o(t), e, i)
			}
			const Pn = t => 1 - Math.sin(Math.acos(t)),
				Vn = nn(Pn),
				An = en(Vn),
				Sn = Tn(.33, 1.53, .69, .99),
				Cn = nn(Sn),
				Mn = en(Cn),
				Rn = {
					linear: wn,
					easeIn: on,
					easeInOut: sn,
					easeOut: rn,
					circIn: Pn,
					circInOut: An,
					circOut: Vn,
					backIn: Cn,
					backInOut: Mn,
					backOut: Sn,
					anticipate: t => (t *= 2) < 1 ? .5 * Cn(t) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
				},
				kn = t => {
					if (Array.isArray(t)) {
						t.length;
						const [e, n, i, o] = t;
						return Tn(e, n, i, o)
					}
					return "string" === typeof t ? Rn[t] : t
				};

			function Ln({
				keyframes: t,
				ease: e = sn,
				times: n,
				duration: i = 300
			}) {
				t = [...t];
				const o = (t => Array.isArray(t) && "number" !== typeof t[0])(e) ? e.map(kn) : kn(e),
					r = {
						done: !1,
						value: t[0]
					},
					s = function(t, e) {
						return t.map((t => t * e))
					}(n && n.length === t.length ? n : function(t) {
						const e = t.length;
						return t.map(((t, n) => 0 !== n ? n / (e - 1) : 0))
					}(t), i);

				function a() {
					return bn(s, t, {
						ease: Array.isArray(o) ? o : (e = t, n = o, e.map((() => n || sn)).splice(0, e.length - 1))
					});
					var e, n
				}
				let l = a();
				return {
					next: t => (r.value = l(t), r.done = t >= i, r),
					flipTarget: () => {
						t.reverse(), l = a()
					}
				}
			}
			const Dn = .001;

			function Bn({
				duration: t = 800,
				bounce: e = .25,
				velocity: n = 0,
				mass: i = 1
			}) {
				let o, r, s = 1 - e;
				s = W(.05, 1, s), t = W(.01, 10, t / 1e3), s < 1 ? (o = e => {
					const i = e * s,
						o = i * t,
						r = i - n,
						a = In(e, s),
						l = Math.exp(-o);
					return Dn - r / a * l
				}, r = e => {
					const i = e * s * t,
						r = i * n + n,
						a = Math.pow(s, 2) * Math.pow(e, 2) * t,
						l = Math.exp(-i),
						u = In(Math.pow(e, 2), s);
					return (-o(e) + Dn > 0 ? -1 : 1) * ((r - a) * l) / u
				}) : (o = e => Math.exp(-e * t) * ((e - n) * t + 1) - .001, r = e => Math.exp(-e * t) * (t * t * (n - e)));
				const a = function(t, e, n) {
					let i = n;
					for (let o = 1; o < 12; o++) i -= t(i) / e(i);
					return i
				}(o, r, 5 / t);
				if (t *= 1e3, isNaN(a)) return {
					stiffness: 100,
					damping: 10,
					duration: t
				}; {
					const e = Math.pow(a, 2) * i;
					return {
						stiffness: e,
						damping: 2 * s * Math.sqrt(i * e),
						duration: t
					}
				}
			}

			function In(t, e) {
				return t * Math.sqrt(1 - e * e)
			}
			const jn = ["duration", "bounce"],
				On = ["stiffness", "damping", "mass"];

			function Fn(t, e) {
				return e.some((e => void 0 !== t[e]))
			}

			function Un({
				keyframes: t,
				restDelta: e,
				restSpeed: n,
				...i
			}) {
				let o = t[0],
					r = t[t.length - 1];
				const s = {
						done: !1,
						value: o
					},
					{
						stiffness: a,
						damping: l,
						mass: u,
						velocity: c,
						duration: h,
						isResolvedFromDuration: d
					} = function(t) {
						let e = {
							velocity: 0,
							stiffness: 100,
							damping: 10,
							mass: 1,
							isResolvedFromDuration: !1,
							...t
						};
						if (!Fn(t, On) && Fn(t, jn)) {
							const n = Bn(t);
							e = {
								...e,
								...n,
								velocity: 0,
								mass: 1
							}, e.isResolvedFromDuration = !0
						}
						return e
					}(i);
				let p = Nn,
					m = c ? -c / 1e3 : 0;
				const f = l / (2 * Math.sqrt(a * u));

				function v() {
					const t = r - o,
						i = Math.sqrt(a / u) / 1e3,
						s = Math.abs(t) < 5;
					if (n || (n = s ? .01 : 2), e || (e = s ? .005 : .5), f < 1) {
						const e = In(i, f);
						p = n => {
							const o = Math.exp(-f * i * n);
							return r - o * ((m + f * i * t) / e * Math.sin(e * n) + t * Math.cos(e * n))
						}
					} else if (1 === f) p = e => r - Math.exp(-i * e) * (t + (m + i * t) * e);
					else {
						const e = i * Math.sqrt(f * f - 1);
						p = n => {
							const o = Math.exp(-f * i * n),
								s = Math.min(e * n, 300);
							return r - o * ((m + f * i * t) * Math.sinh(s) + e * t * Math.cosh(s)) / e
						}
					}
				}
				return v(), {
					next: t => {
						const i = p(t);
						if (d) s.done = t >= h;
						else {
							let o = m;
							if (0 !== t)
								if (f < 1) {
									const e = Math.max(0, t - 5);
									o = ye(i - p(e), t - e)
								} else o = 0;
							const a = Math.abs(o) <= n,
								l = Math.abs(r - i) <= e;
							s.done = a && l
						}
						return s.value = s.done ? r : i, s
					},
					flipTarget: () => {
						m = -m, [o, r] = [r, o], v()
					}
				}
			}
			Un.needsInterpolation = (t, e) => "string" === typeof t || "string" === typeof e;
			const Nn = t => 0;
			const zn = {
				decay: function({
					keyframes: t = [0],
					velocity: e = 0,
					power: n = .8,
					timeConstant: i = 350,
					restDelta: o = .5,
					modifyTarget: r
				}) {
					const s = t[0],
						a = {
							done: !1,
							value: s
						};
					let l = n * e;
					const u = s + l,
						c = void 0 === r ? u : r(u);
					return c !== u && (l = c - s), {
						next: t => {
							const e = -l * Math.exp(-t / i);
							return a.done = !(e > o || e < -o), a.value = a.done ? c : c + e, a
						},
						flipTarget: () => {}
					}
				},
				keyframes: Ln,
				tween: Ln,
				spring: Un
			};

			function Wn(t, e, n = 0) {
				return t - e - n
			}
			const $n = t => {
				const e = ({
					delta: e
				}) => t(e);
				return {
					start: () => me.Z_.update(e, !0),
					stop: () => me.qY.update(e)
				}
			};

			function Yn({
				duration: t,
				driver: e = $n,
				elapsed: n = 0,
				repeat: i = 0,
				repeatType: o = "loop",
				repeatDelay: r = 0,
				keyframes: s,
				autoplay: a = !0,
				onPlay: l,
				onStop: u,
				onComplete: c,
				onRepeat: h,
				onUpdate: d,
				type: p = "keyframes",
				...m
			}) {
				var f, v;
				const g = n;
				let y, x, b = 0,
					w = t,
					E = !1,
					T = !0;
				const P = zn[s.length > 2 ? "keyframes" : p] || Ln,
					V = s[0],
					A = s[s.length - 1];
				let S = {
					done: !1,
					value: V
				};
				(null === (v = (f = P).needsInterpolation) || void 0 === v ? void 0 : v.call(f, V, A)) && (x = bn([0, 100], [V, A], {
					clamp: !1
				}), s = [0, 100]);
				const C = P({
					...m,
					duration: t,
					keyframes: s
				});

				function M() {
					b++, "reverse" === o ? (T = b % 2 === 0, n = function(t, e = 0, n = 0, i = !0) {
						return i ? Wn(e + -t, e, n) : e - (t - e) + n
					}(n, w, r, T)) : (n = Wn(n, w, r), "mirror" === o && C.flipTarget()), E = !1, h && h()
				}

				function R(t) {
					T || (t = -t), n += t, E || (S = C.next(Math.max(0, n)), x && (S.value = x(S.value)), E = T ? S.done : n <= 0), d && d(S.value), E && (0 === b && (w = void 0 !== w ? w : n), b < i ? function(t, e, n, i) {
						return i ? t >= e + n : t <= -n
					}(n, w, r, T) && M() : (y && y.stop(), c && c()))
				}
				return a && (l && l(), y = e(R), y.start()), {
					stop: () => {
						u && u(), y && y.stop()
					},
					set currentTime(t) {
						n = g, R(t)
					},
					sample: e => {
						n = g;
						const i = t && "number" === typeof t ? Math.max(.5 * t, 50) : 50;
						let o = 0;
						for (R(0); o <= e;) {
							const t = e - o;
							R(Math.min(t, i)), o += i
						}
						return S
					}
				}
			}
			const _n = ([t, e, n, i]) => `cubic-bezier(${t}, ${e}, ${n}, ${i})`,
				Hn = {
					linear: "linear",
					ease: "ease",
					easeIn: "ease-in",
					easeOut: "ease-out",
					easeInOut: "ease-in-out",
					circIn: _n([0, .65, .55, 1]),
					circOut: _n([.55, 0, 1, .45]),
					backIn: _n([.31, .01, .66, -.59]),
					backOut: _n([.33, 1.53, .69, .99])
				};

			function Zn(t) {
				if (t) return Array.isArray(t) ? _n(t) : Hn[t]
			}
			const qn = {
					waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate")
				},
				Xn = {},
				Gn = {};
			for (const Wr in qn) Gn[Wr] = () => (void 0 === Xn[Wr] && (Xn[Wr] = qn[Wr]()), Xn[Wr]);
			const Kn = new Set(["opacity"]);

			function Jn(t, e, {
				onUpdate: n,
				onComplete: i,
				...o
			}) {
				if (!(Gn.waapi() && Kn.has(e) && !o.repeatDelay && "mirror" !== o.repeatType && 0 !== o.damping)) return !1;
				let {
					keyframes: r,
					duration: s = 300,
					elapsed: a = 0,
					ease: l
				} = o;
				if ("spring" === o.type || !(!(u = o.ease) || Array.isArray(u) || "string" === typeof u && Hn[u])) {
					if (o.repeat === 1 / 0) return;
					const t = Yn({
						...o,
						elapsed: 0
					});
					let e = {
						done: !1,
						value: r[0]
					};
					const n = [];
					let i = 0;
					for (; !e.done && i < 2e4;) e = t.sample(i), n.push(e.value), i += 10;
					r = n, s = i - 10, l = "linear"
				}
				var u;
				const c = function(t, e, n, {
					delay: i = 0,
					duration: o,
					repeat: r = 0,
					repeatType: s = "loop",
					ease: a,
					times: l
				} = {}) {
					return t.animate({
						[e]: n,
						offset: l
					}, {
						delay: i,
						duration: o,
						easing: Zn(a),
						fill: "both",
						iterations: r + 1,
						direction: "reverse" === s ? "alternate" : "normal"
					})
				}(t.owner.current, e, r, {
					...o,
					delay: -a,
					duration: s,
					ease: l
				});
				return c.onfinish = () => {
					t.set(function(t, {
						repeat: e,
						repeatType: n = "loop"
					}) {
						return t[e && "loop" !== n && e % 2 === 1 ? 0 : t.length - 1]
					}(r, o)), me.Z_.update((() => c.cancel())), i && i()
				}, {
					get currentTime() {
						return c.currentTime || 0
					},
					set currentTime(t) {
						c.currentTime = t
					},
					stop: () => {
						const {
							currentTime: e
						} = c;
						if (e) {
							const n = Yn({
								...o,
								autoplay: !1
							});
							t.setWithVelocity(n.sample(e - 10).value, n.sample(e).value, 10)
						}
						me.Z_.update((() => c.cancel()))
					}
				}
			}

			function Qn(t, e) {
				const n = performance.now(),
					i = ({
						timestamp: o
					}) => {
						const r = o - n;
						r >= e && (me.qY.read(i), t(r - e))
					};
				return me.Z_.read(i, !0), () => me.qY.read(i)
			}

			function ti({
				keyframes: t,
				elapsed: e,
				onUpdate: n,
				onComplete: i
			}) {
				const o = () => {
					n && n(t[t.length - 1]), i && i()
				};
				return e ? {
					stop: Qn(o, -e)
				} : o()
			}
			const ei = () => ({
					type: "spring",
					stiffness: 500,
					damping: 25,
					restSpeed: 10
				}),
				ni = t => ({
					type: "spring",
					stiffness: 550,
					damping: 0 === t ? 2 * Math.sqrt(550) : 30,
					restSpeed: 10
				}),
				ii = () => ({
					type: "keyframes",
					ease: "linear",
					duration: .3
				}),
				oi = {
					type: "keyframes",
					duration: .8
				},
				ri = {
					x: ei,
					y: ei,
					z: ei,
					rotate: ei,
					rotateX: ei,
					rotateY: ei,
					rotateZ: ei,
					scaleX: ni,
					scaleY: ni,
					scale: ni,
					opacity: ii,
					backgroundColor: ii,
					color: ii,
					default: ni
				},
				si = (t, {
					keyframes: e
				}) => {
					if (e.length > 2) return oi;
					return (ri[t] || ri.default)(e[1])
				},
				ai = (t, e) => "zIndex" !== t && (!("number" !== typeof e && !Array.isArray(e)) || !("string" !== typeof e || !Be.test(e) || e.startsWith("url(")));

			function li(t) {
				return 0 === t || "string" === typeof t && 0 === parseFloat(t) && -1 === t.indexOf(" ")
			}

			function ui(t) {
				return "number" === typeof t ? 0 : ze("", t)
			}

			function ci(t, e) {
				return t[e] || t.default || t
			}
			const hi = (t, e, n, i = {}) => o => {
				const r = ci(i, t) || {},
					s = r.delay || i.delay || 0;
				let {
					elapsed: a = 0
				} = i;
				a -= Qe(s);
				const l = function(t, e, n, i) {
						const o = ai(e, n);
						let r = void 0 !== i.from ? i.from : t.get();
						return "none" === r && o && "string" === typeof n ? r = ze(e, n) : li(r) && "string" === typeof n ? r = ui(n) : !Array.isArray(n) && li(n) && "string" === typeof r && (n = ui(r)), Array.isArray(n) ? (null === n[0] && (n[0] = r), n) : [r, n]
					}(e, t, n, r),
					u = l[0],
					c = l[l.length - 1],
					h = ai(t, u),
					d = ai(t, c);
				let p = {
					keyframes: l,
					velocity: e.getVelocity(),
					...r,
					elapsed: a,
					onUpdate: t => {
						e.set(t), r.onUpdate && r.onUpdate(t)
					},
					onComplete: () => {
						o(), r.onComplete && r.onComplete()
					}
				};
				if (!h || !d || tn || !1 === r.type) return ti(p);
				if ("inertia" === r.type) return function({
					keyframes: t,
					velocity: e = 0,
					min: n,
					max: i,
					power: o = .8,
					timeConstant: r = 750,
					bounceStiffness: s = 500,
					bounceDamping: a = 10,
					restDelta: l = 1,
					modifyTarget: u,
					driver: c,
					onUpdate: h,
					onComplete: d,
					onStop: p
				}) {
					const m = t[0];
					let f;

					function v(t) {
						return void 0 !== n && t < n || void 0 !== i && t > i
					}

					function g(t) {
						return void 0 === n ? i : void 0 === i || Math.abs(n - t) < Math.abs(i - t) ? n : i
					}

					function y(t) {
						null === f || void 0 === f || f.stop(), f = Yn({
							keyframes: [0, 1],
							velocity: 0,
							...t,
							driver: c,
							onUpdate: e => {
								var n;
								null === h || void 0 === h || h(e), null === (n = t.onUpdate) || void 0 === n || n.call(t, e)
							},
							onComplete: d,
							onStop: p
						})
					}

					function x(t) {
						y({
							type: "spring",
							stiffness: s,
							damping: a,
							restDelta: l,
							...t
						})
					}
					if (v(m)) x({
						velocity: e,
						keyframes: [m, g(m)]
					});
					else {
						let t = o * e + m;
						"undefined" !== typeof u && (t = u(t));
						const i = g(t),
							s = i === n ? -1 : 1;
						let a, c;
						const h = t => {
							a = c, c = t, e = ye(t - a, pe.w.delta), (1 === s && t > i || -1 === s && t < i) && x({
								keyframes: [t, i],
								velocity: e
							})
						};
						y({
							type: "decay",
							keyframes: [m, 0],
							velocity: e,
							timeConstant: r,
							power: o,
							restDelta: l,
							modifyTarget: u,
							onUpdate: v(t) ? h : void 0
						})
					}
					return {
						stop: () => null === f || void 0 === f ? void 0 : f.stop()
					}
				}(p);
				(function({
					when: t,
					delay: e,
					delayChildren: n,
					staggerChildren: i,
					staggerDirection: o,
					repeat: r,
					repeatType: s,
					repeatDelay: a,
					from: l,
					elapsed: u,
					...c
				}) {
					return !!Object.keys(c).length
				})(r) || (p = {
					...p,
					...si(t, p)
				}), p.duration && (p.duration = Qe(p.duration)), p.repeatDelay && (p.repeatDelay = Qe(p.repeatDelay));
				const m = e.owner,
					f = m && m.current;
				if (m && f instanceof HTMLElement && !(null === m || void 0 === m ? void 0 : m.getProps().onUpdate)) {
					const n = Jn(e, t, p);
					if (n) return n
				}
				return Yn(p)
			};

			function di(t, e, n = {}) {
				var i;
				const o = Ze(t, e, n.custom);
				let {
					transition: r = t.getDefaultTransition() || {}
				} = o || {};
				n.transitionOverride && (r = n.transitionOverride);
				const s = o ? () => pi(t, o, n) : () => Promise.resolve(),
					a = (null === (i = t.variantChildren) || void 0 === i ? void 0 : i.size) ? (i = 0) => {
						const {
							delayChildren: o = 0,
							staggerChildren: s,
							staggerDirection: a
						} = r;
						return function(t, e, n = 0, i = 0, o = 1, r) {
							const s = [],
								a = (t.variantChildren.size - 1) * i,
								l = 1 === o ? (t = 0) => t * i : (t = 0) => a - t * i;
							return Array.from(t.variantChildren).sort(mi).forEach(((t, i) => {
								t.notify("AnimationStart", e), s.push(di(t, e, {
									...r,
									delay: n + l(i)
								}).then((() => t.notify("AnimationComplete", e))))
							})), Promise.all(s)
						}(t, e, o + i, s, a, n)
					} : () => Promise.resolve(),
					{
						when: l
					} = r;
				if (l) {
					const [t, e] = "beforeChildren" === l ? [s, a] : [a, s];
					return t().then(e)
				}
				return Promise.all([s(), a(n.delay)])
			}

			function pi(t, e, {
				delay: n = 0,
				transitionOverride: i,
				type: o
			} = {}) {
				var r;
				let {
					transition: s = t.getDefaultTransition(),
					transitionEnd: a,
					...l
				} = t.makeTargetAnimatable(e);
				const u = t.getValue("willChange");
				i && (s = i);
				const c = [],
					h = o && (null === (r = t.animationState) || void 0 === r ? void 0 : r.getState()[o]);
				for (const d in l) {
					const e = t.getValue(d),
						i = l[d];
					if (!e || void 0 === i || h && fi(h, d)) continue;
					const o = {
						delay: n,
						elapsed: 0,
						...s
					};
					if (window.HandoffAppearAnimations && !e.hasAnimated) {
						const n = t.getProps()[Je];
						n && (o.elapsed = window.HandoffAppearAnimations(n, d, e, me.Z_))
					}
					let r = e.start(hi(d, e, i, t.shouldReduceMotion && I.has(d) ? {
						type: !1
					} : o));
					Ke(u) && (u.add(d), r = r.then((() => u.remove(d)))), c.push(r)
				}
				return Promise.all(c).then((() => {
					a && Xe(t, a)
				}))
			}

			function mi(t, e) {
				return t.sortNodePosition(e)
			}

			function fi({
				protectedKeys: t,
				needsAnimating: e
			}, n) {
				const i = t.hasOwnProperty(n) && !0 !== e[n];
				return e[n] = !1, i
			}
			const vi = [jt.Animate, jt.InView, jt.Focus, jt.Hover, jt.Tap, jt.Drag, jt.Exit],
				gi = [...vi].reverse(),
				yi = vi.length;

			function xi(t) {
				return e => Promise.all(e.map((({
					animation: e,
					options: n
				}) => function(t, e, n = {}) {
					let i;
					if (t.notify("AnimationStart", e), Array.isArray(e)) {
						const o = e.map((e => di(t, e, n)));
						i = Promise.all(o)
					} else if ("string" === typeof e) i = di(t, e, n);
					else {
						const o = "function" === typeof e ? Ze(t, e, n.custom) : e;
						i = pi(t, o, n)
					}
					return i.then((() => t.notify("AnimationComplete", e)))
				}(t, e, n))))
			}

			function bi(t) {
				let e = xi(t);
				const n = {
					[jt.Animate]: Ei(!0),
					[jt.InView]: Ei(),
					[jt.Hover]: Ei(),
					[jt.Tap]: Ei(),
					[jt.Drag]: Ei(),
					[jt.Focus]: Ei(),
					[jt.Exit]: Ei()
				};
				let i = !0;
				const o = (e, n) => {
					const i = Ze(t, n);
					if (i) {
						const {
							transition: t,
							transitionEnd: n,
							...o
						} = i;
						e = {
							...e,
							...o,
							...n
						}
					}
					return e
				};

				function r(r, s) {
					const a = t.getProps(),
						l = t.getVariantContext(!0) || {},
						u = [],
						c = new Set;
					let p = {},
						m = 1 / 0;
					for (let e = 0; e < yi; e++) {
						const f = gi[e],
							v = n[f],
							g = void 0 !== a[f] ? a[f] : l[f],
							y = h(g),
							x = f === s ? v.isActive : null;
						!1 === x && (m = e);
						let b = g === l[f] && g !== a[f] && y;
						if (b && i && t.manuallyAnimateOnMount && (b = !1), v.protectedKeys = {
								...p
							}, !v.isActive && null === x || !g && !v.prevProp || d(g) || "boolean" === typeof g) continue;
						const w = wi(v.prevProp, g);
						let E = w || f === s && v.isActive && !b && y || e > m && y;
						const T = Array.isArray(g) ? g : [g];
						let P = T.reduce(o, {});
						!1 === x && (P = {});
						const {
							prevResolvedValues: V = {}
						} = v, A = {
							...V,
							...P
						}, S = t => {
							E = !0, c.delete(t), v.needsAnimating[t] = !0
						};
						for (const t in A) {
							const e = P[t],
								n = V[t];
							p.hasOwnProperty(t) || (e !== n ? Rt(e) && Rt(n) ? !he(e, n) || w ? S(t) : v.protectedKeys[t] = !0 : void 0 !== e ? S(t) : c.add(t) : void 0 !== e && c.has(t) ? S(t) : v.protectedKeys[t] = !0)
						}
						v.prevProp = g, v.prevResolvedValues = P, v.isActive && (p = {
							...p,
							...P
						}), i && t.blockInitialAnimation && (E = !1), E && !b && u.push(...T.map((t => ({
							animation: t,
							options: {
								type: f,
								...r
							}
						}))))
					}
					if (c.size) {
						const e = {};
						c.forEach((n => {
							const i = t.getBaseTarget(n);
							void 0 !== i && (e[n] = i)
						})), u.push({
							animation: e
						})
					}
					let f = Boolean(u.length);
					return i && !1 === a.initial && !t.manuallyAnimateOnMount && (f = !1), i = !1, f ? e(u) : Promise.resolve()
				}
				return {
					animateChanges: r,
					setActive: function(e, i, o) {
						var s;
						if (n[e].isActive === i) return Promise.resolve();
						null === (s = t.variantChildren) || void 0 === s || s.forEach((t => {
							var n;
							return null === (n = t.animationState) || void 0 === n ? void 0 : n.setActive(e, i)
						})), n[e].isActive = i;
						const a = r(o, e);
						for (const t in n) n[t].protectedKeys = {};
						return a
					},
					setAnimateFunction: function(n) {
						e = n(t)
					},
					getState: () => n
				}
			}

			function wi(t, e) {
				return "string" === typeof e ? e !== t : !!Array.isArray(e) && !he(e, t)
			}

			function Ei(t = !1) {
				return {
					isActive: t,
					protectedKeys: {},
					needsAnimating: {},
					prevResolvedValues: {}
				}
			}
			const Ti = {
					animation: le((({
						visualElement: t,
						animate: e
					}) => {
						t.animationState || (t.animationState = bi(t)), d(e) && (0, i.useEffect)((() => e.subscribe(t)), [e])
					})),
					exit: le((t => {
						const {
							custom: e,
							visualElement: n
						} = t, [o, r] = ce(), a = (0, i.useContext)(s.O);
						(0, i.useEffect)((() => {
							n.isPresent = o;
							const t = n.animationState && n.animationState.setActive(jt.Exit, !o, {
								custom: a && a.custom || e
							});
							t && !o && t.then(r)
						}), [o])
					}))
				},
				Pi = (t, e) => Math.abs(t - e);
			class Vi {
				constructor(t, e, {
					transformPagePoint: n
				} = {}) {
					if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = () => {
							if (!this.lastMoveEvent || !this.lastMoveEventInfo) return;
							const t = Ci(this.lastMoveEventInfo, this.history),
								e = null !== this.startEvent,
								n = function(t, e) {
									const n = Pi(t.x, e.x),
										i = Pi(t.y, e.y);
									return Math.sqrt(n ** 2 + i ** 2)
								}(t.offset, {
									x: 0,
									y: 0
								}) >= 3;
							if (!e && !n) return;
							const {
								point: i
							} = t, {
								timestamp: o
							} = pe.w;
							this.history.push({
								...i,
								timestamp: o
							});
							const {
								onStart: r,
								onMove: s
							} = this.handlers;
							e || (r && r(this.lastMoveEvent, t), this.startEvent = this.lastMoveEvent), s && s(this.lastMoveEvent, t)
						}, this.handlePointerMove = (t, e) => {
							this.lastMoveEvent = t, this.lastMoveEventInfo = Ai(e, this.transformPagePoint), me.Z_.update(this.updatePoint, !0)
						}, this.handlePointerUp = (t, e) => {
							if (this.end(), !this.lastMoveEvent || !this.lastMoveEventInfo) return;
							const {
								onEnd: n,
								onSessionEnd: i
							} = this.handlers, o = Ci("pointercancel" === t.type ? this.lastMoveEventInfo : Ai(e, this.transformPagePoint), this.history);
							this.startEvent && n && n(t, o), i && i(t, o)
						}, !Ut(t)) return;
					this.handlers = e, this.transformPagePoint = n;
					const i = Ai(Nt(t), this.transformPagePoint),
						{
							point: o
						} = i,
						{
							timestamp: r
						} = pe.w;
					this.history = [{
						...o,
						timestamp: r
					}];
					const {
						onSessionStart: s
					} = e;
					s && s(t, Ci(i, this.history)), this.removeListeners = Qt(Wt(window, "pointermove", this.handlePointerMove), Wt(window, "pointerup", this.handlePointerUp), Wt(window, "pointercancel", this.handlePointerUp))
				}
				updateHandlers(t) {
					this.handlers = t
				}
				end() {
					this.removeListeners && this.removeListeners(), me.qY.update(this.updatePoint)
				}
			}

			function Ai(t, e) {
				return e ? {
					point: e(t.point)
				} : t
			}

			function Si(t, e) {
				return {
					x: t.x - e.x,
					y: t.y - e.y
				}
			}

			function Ci({
				point: t
			}, e) {
				return {
					point: t,
					delta: Si(t, Ri(e)),
					offset: Si(t, Mi(e)),
					velocity: ki(e, .1)
				}
			}

			function Mi(t) {
				return t[0]
			}

			function Ri(t) {
				return t[t.length - 1]
			}

			function ki(t, e) {
				if (t.length < 2) return {
					x: 0,
					y: 0
				};
				let n = t.length - 1,
					i = null;
				const o = Ri(t);
				for (; n >= 0 && (i = t[n], !(o.timestamp - i.timestamp > Qe(e)));) n--;
				if (!i) return {
					x: 0,
					y: 0
				};
				const r = (o.timestamp - i.timestamp) / 1e3;
				if (0 === r) return {
					x: 0,
					y: 0
				};
				const s = {
					x: (o.x - i.x) / r,
					y: (o.y - i.y) / r
				};
				return s.x === 1 / 0 && (s.x = 0), s.y === 1 / 0 && (s.y = 0), s
			}

			function Li(t) {
				return t.max - t.min
			}

			function Di(t, e = 0, n = .01) {
				return Math.abs(t - e) <= n
			}

			function Bi(t, e, n, i = .5) {
				t.origin = i, t.originPoint = an(e.min, e.max, t.origin), t.scale = Li(n) / Li(e), (Di(t.scale, 1, 1e-4) || isNaN(t.scale)) && (t.scale = 1), t.translate = an(n.min, n.max, t.origin) - t.originPoint, (Di(t.translate) || isNaN(t.translate)) && (t.translate = 0)
			}

			function Ii(t, e, n, i) {
				Bi(t.x, e.x, n.x, null === i || void 0 === i ? void 0 : i.originX), Bi(t.y, e.y, n.y, null === i || void 0 === i ? void 0 : i.originY)
			}

			function ji(t, e, n) {
				t.min = n.min + e.min, t.max = t.min + Li(e)
			}

			function Oi(t, e, n) {
				t.min = e.min - n.min, t.max = t.min + Li(e)
			}

			function Fi(t, e, n) {
				Oi(t.x, e.x, n.x), Oi(t.y, e.y, n.y)
			}

			function Ui(t, e, n) {
				return {
					min: void 0 !== e ? t.min + e : void 0,
					max: void 0 !== n ? t.max + n - (t.max - t.min) : void 0
				}
			}

			function Ni(t, e) {
				let n = e.min - t.min,
					i = e.max - t.max;
				return e.max - e.min < t.max - t.min && ([n, i] = [i, n]), {
					min: n,
					max: i
				}
			}
			const zi = .35;

			function Wi(t, e, n) {
				return {
					min: $i(t, e),
					max: $i(t, n)
				}
			}

			function $i(t, e) {
				return "number" === typeof t ? t : t[e] || 0
			}

			function Yi(t) {
				return [t("x"), t("y")]
			}

			function _i({
				top: t,
				left: e,
				right: n,
				bottom: i
			}) {
				return {
					x: {
						min: e,
						max: n
					},
					y: {
						min: t,
						max: i
					}
				}
			}

			function Hi(t) {
				return void 0 === t || 1 === t
			}

			function Zi({
				scale: t,
				scaleX: e,
				scaleY: n
			}) {
				return !Hi(t) || !Hi(e) || !Hi(n)
			}

			function qi(t) {
				return Zi(t) || Xi(t) || t.z || t.rotate || t.rotateX || t.rotateY
			}

			function Xi(t) {
				return Gi(t.x) || Gi(t.y)
			}

			function Gi(t) {
				return t && "0%" !== t
			}

			function Ki(t, e, n) {
				return n + e * (t - n)
			}

			function Ji(t, e, n, i, o) {
				return void 0 !== o && (t = Ki(t, o, i)), Ki(t, n, i) + e
			}

			function Qi(t, e = 0, n = 1, i, o) {
				t.min = Ji(t.min, e, n, i, o), t.max = Ji(t.max, e, n, i, o)
			}

			function to(t, {
				x: e,
				y: n
			}) {
				Qi(t.x, e.translate, e.scale, e.originPoint), Qi(t.y, n.translate, n.scale, n.originPoint)
			}

			function eo(t) {
				return Number.isInteger(t) || t > 1.0000000000001 || t < .999999999999 ? t : 1
			}

			function no(t, e) {
				t.min = t.min + e, t.max = t.max + e
			}

			function io(t, e, [n, i, o]) {
				const r = void 0 !== e[o] ? e[o] : .5,
					s = an(t.min, t.max, r);
				Qi(t, e[n], e[i], s, e.scale)
			}
			const oo = ["x", "scaleX", "originX"],
				ro = ["y", "scaleY", "originY"];

			function so(t, e) {
				io(t.x, e, oo), io(t.y, e, ro)
			}

			function ao(t, e) {
				return _i(function(t, e) {
					if (!e) return t;
					const n = e({
							x: t.left,
							y: t.top
						}),
						i = e({
							x: t.right,
							y: t.bottom
						});
					return {
						top: n.y,
						left: n.x,
						bottom: i.y,
						right: i.x
					}
				}(t.getBoundingClientRect(), e))
			}
			const lo = new WeakMap;
			class uo {
				constructor(t) {
					this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = {
						x: 0,
						y: 0
					}, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = {
						x: {
							min: 0,
							max: 0
						},
						y: {
							min: 0,
							max: 0
						}
					}, this.visualElement = t
				}
				start(t, {
					snapToCursor: e = !1
				} = {}) {
					if (!1 === this.visualElement.isPresent) return;
					this.panSession = new Vi(t, {
						onSessionStart: t => {
							this.stopAnimation(), e && this.snapToCursor(Nt(t, "page").point)
						},
						onStart: (t, e) => {
							var n;
							const {
								drag: i,
								dragPropagation: o,
								onDragStart: r
							} = this.getProps();
							(!i || o || (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = Zt(i), this.openGlobalLock)) && (this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Yi((t => {
								var e, n;
								let i = this.getAxisMotionValue(t).get() || 0;
								if (Q.test(i)) {
									const o = null === (n = null === (e = this.visualElement.projection) || void 0 === e ? void 0 : e.layout) || void 0 === n ? void 0 : n.layoutBox[t];
									if (o) {
										i = Li(o) * (parseFloat(i) / 100)
									}
								}
								this.originPoint[t] = i
							})), null === r || void 0 === r || r(t, e), null === (n = this.visualElement.animationState) || void 0 === n || n.setActive(jt.Drag, !0))
						},
						onMove: (t, e) => {
							const {
								dragPropagation: n,
								dragDirectionLock: i,
								onDirectionLock: o,
								onDrag: r
							} = this.getProps();
							if (!n && !this.openGlobalLock) return;
							const {
								offset: s
							} = e;
							if (i && null === this.currentDirection) return this.currentDirection = function(t, e = 10) {
								let n = null;
								Math.abs(t.y) > e ? n = "y" : Math.abs(t.x) > e && (n = "x");
								return n
							}(s), void(null !== this.currentDirection && (null === o || void 0 === o || o(this.currentDirection)));
							this.updateAxis("x", e.point, s), this.updateAxis("y", e.point, s), this.visualElement.render(), null === r || void 0 === r || r(t, e)
						},
						onSessionEnd: (t, e) => this.stop(t, e)
					}, {
						transformPagePoint: this.visualElement.getTransformPagePoint()
					})
				}
				stop(t, e) {
					const n = this.isDragging;
					if (this.cancel(), !n) return;
					const {
						velocity: i
					} = e;
					this.startAnimation(i);
					const {
						onDragEnd: o
					} = this.getProps();
					null === o || void 0 === o || o(t, e)
				}
				cancel() {
					var t, e;
					this.isDragging = !1, this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !1), null === (t = this.panSession) || void 0 === t || t.end(), this.panSession = void 0;
					const {
						dragPropagation: n
					} = this.getProps();
					!n && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), null === (e = this.visualElement.animationState) || void 0 === e || e.setActive(jt.Drag, !1)
				}
				updateAxis(t, e, n) {
					const {
						drag: i
					} = this.getProps();
					if (!n || !co(t, i, this.currentDirection)) return;
					const o = this.getAxisMotionValue(t);
					let r = this.originPoint[t] + n[t];
					this.constraints && this.constraints[t] && (r = function(t, {
						min: e,
						max: n
					}, i) {
						return void 0 !== e && t < e ? t = i ? an(e, t, i.min) : Math.max(t, e) : void 0 !== n && t > n && (t = i ? an(n, t, i.max) : Math.min(t, n)), t
					}(r, this.constraints[t], this.elastic[t])), o.set(r)
				}
				resolveConstraints() {
					const {
						dragConstraints: t,
						dragElastic: e
					} = this.getProps(), {
						layout: n
					} = this.visualElement.projection || {}, i = this.constraints;
					t && c(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : this.constraints = !(!t || !n) && function(t, {
						top: e,
						left: n,
						bottom: i,
						right: o
					}) {
						return {
							x: Ui(t.x, n, o),
							y: Ui(t.y, e, i)
						}
					}(n.layoutBox, t), this.elastic = function(t = zi) {
						return !1 === t ? t = 0 : !0 === t && (t = zi), {
							x: Wi(t, "left", "right"),
							y: Wi(t, "top", "bottom")
						}
					}(e), i !== this.constraints && n && this.constraints && !this.hasMutatedConstraints && Yi((t => {
						this.getAxisMotionValue(t) && (this.constraints[t] = function(t, e) {
							const n = {};
							return void 0 !== e.min && (n.min = e.min - t.min), void 0 !== e.max && (n.max = e.max - t.min), n
						}(n.layoutBox[t], this.constraints[t]))
					}))
				}
				resolveRefConstraints() {
					const {
						dragConstraints: t,
						onMeasureDragConstraints: e
					} = this.getProps();
					if (!t || !c(t)) return !1;
					const n = t.current,
						{
							projection: i
						} = this.visualElement;
					if (!i || !i.layout) return !1;
					const o = function(t, e, n) {
						const i = ao(t, n),
							{
								scroll: o
							} = e;
						return o && (no(i.x, o.offset.x), no(i.y, o.offset.y)), i
					}(n, i.root, this.visualElement.getTransformPagePoint());
					let r = function(t, e) {
						return {
							x: Ni(t.x, e.x),
							y: Ni(t.y, e.y)
						}
					}(i.layout.layoutBox, o);
					if (e) {
						const t = e(function({
							x: t,
							y: e
						}) {
							return {
								top: e.min,
								right: t.max,
								bottom: e.max,
								left: t.min
							}
						}(r));
						this.hasMutatedConstraints = !!t, t && (r = _i(t))
					}
					return r
				}
				startAnimation(t) {
					const {
						drag: e,
						dragMomentum: n,
						dragElastic: i,
						dragTransition: o,
						dragSnapToOrigin: r,
						onDragTransitionEnd: s
					} = this.getProps(), a = this.constraints || {}, l = Yi((s => {
						if (!co(s, e, this.currentDirection)) return;
						let l = (null === a || void 0 === a ? void 0 : a[s]) || {};
						r && (l = {
							min: 0,
							max: 0
						});
						const u = i ? 200 : 1e6,
							c = i ? 40 : 1e7,
							h = {
								type: "inertia",
								velocity: n ? t[s] : 0,
								bounceStiffness: u,
								bounceDamping: c,
								timeConstant: 750,
								restDelta: 1,
								restSpeed: 10,
								...o,
								...l
							};
						return this.startAxisValueAnimation(s, h)
					}));
					return Promise.all(l).then(s)
				}
				startAxisValueAnimation(t, e) {
					const n = this.getAxisMotionValue(t);
					return n.start(hi(t, n, 0, e))
				}
				stopAnimation() {
					Yi((t => this.getAxisMotionValue(t).stop()))
				}
				getAxisMotionValue(t) {
					var e;
					const n = "_drag" + t.toUpperCase(),
						i = this.visualElement.getProps()[n];
					return i || this.visualElement.getValue(t, (null === (e = this.visualElement.getProps().initial) || void 0 === e ? void 0 : e[t]) || 0)
				}
				snapToCursor(t) {
					Yi((e => {
						const {
							drag: n
						} = this.getProps();
						if (!co(e, n, this.currentDirection)) return;
						const {
							projection: i
						} = this.visualElement, o = this.getAxisMotionValue(e);
						if (i && i.layout) {
							const {
								min: n,
								max: r
							} = i.layout.layoutBox[e];
							o.set(t[e] - an(n, r, .5))
						}
					}))
				}
				scalePositionWithinConstraints() {
					var t;
					if (!this.visualElement.current) return;
					const {
						drag: e,
						dragConstraints: n
					} = this.getProps(), {
						projection: i
					} = this.visualElement;
					if (!c(n) || !i || !this.constraints) return;
					this.stopAnimation();
					const o = {
						x: 0,
						y: 0
					};
					Yi((t => {
						const e = this.getAxisMotionValue(t);
						if (e) {
							const n = e.get();
							o[t] = function(t, e) {
								let n = .5;
								const i = Li(t),
									o = Li(e);
								return o > i ? n = gn(e.min, e.max - i, t.min) : i > o && (n = gn(t.min, t.max - o, e.min)), W(0, 1, n)
							}({
								min: n,
								max: n
							}, this.constraints[t])
						}
					}));
					const {
						transformTemplate: r
					} = this.visualElement.getProps();
					this.visualElement.current.style.transform = r ? r({}, "") : "none", null === (t = i.root) || void 0 === t || t.updateScroll(), i.updateLayout(), this.resolveConstraints(), Yi((t => {
						if (!co(t, e, null)) return;
						const n = this.getAxisMotionValue(t),
							{
								min: i,
								max: r
							} = this.constraints[t];
						n.set(an(i, r, o[t]))
					}))
				}
				addListeners() {
					var t;
					if (!this.visualElement.current) return;
					lo.set(this.visualElement, this);
					const e = Wt(this.visualElement.current, "pointerdown", (t => {
							const {
								drag: e,
								dragListener: n = !0
							} = this.getProps();
							e && n && this.start(t)
						})),
						n = () => {
							const {
								dragConstraints: t
							} = this.getProps();
							c(t) && (this.constraints = this.resolveRefConstraints())
						},
						{
							projection: i
						} = this.visualElement,
						o = i.addEventListener("measure", n);
					i && !i.layout && (null === (t = i.root) || void 0 === t || t.updateScroll(), i.updateLayout()), n();
					const r = Ot(window, "resize", (() => this.scalePositionWithinConstraints())),
						s = i.addEventListener("didUpdate", (({
							delta: t,
							hasLayoutChanged: e
						}) => {
							this.isDragging && e && (Yi((e => {
								const n = this.getAxisMotionValue(e);
								n && (this.originPoint[e] += t[e].translate, n.set(n.get() + t[e].translate))
							})), this.visualElement.render())
						}));
					return () => {
						r(), e(), o(), null === s || void 0 === s || s()
					}
				}
				getProps() {
					const t = this.visualElement.getProps(),
						{
							drag: e = !1,
							dragDirectionLock: n = !1,
							dragPropagation: i = !1,
							dragConstraints: o = !1,
							dragElastic: r = zi,
							dragMomentum: s = !0
						} = t;
					return {
						...t,
						drag: e,
						dragDirectionLock: n,
						dragPropagation: i,
						dragConstraints: o,
						dragElastic: r,
						dragMomentum: s
					}
				}
			}

			function co(t, e, n) {
				return (!0 === e || e === t) && (null === n || n === t)
			}
			const ho = {
				pan: le((function({
					onPan: t,
					onPanStart: e,
					onPanEnd: n,
					onPanSessionStart: r,
					visualElement: s
				}) {
					const a = t || e || n || r,
						l = (0, i.useRef)(null),
						{
							transformPagePoint: u
						} = (0, i.useContext)(o),
						c = {
							onSessionStart: r,
							onStart: e,
							onMove: t,
							onEnd: (t, e) => {
								l.current = null, n && n(t, e)
							}
						};
					(0, i.useEffect)((() => {
						null !== l.current && l.current.updateHandlers(c)
					})), $t(s, "pointerdown", a && function(t) {
						l.current = new Vi(t, c, {
							transformPagePoint: u
						})
					}), (0, Kt.z)((() => l.current && l.current.end()))
				})),
				drag: le((function(t) {
					const {
						dragControls: e,
						visualElement: n
					} = t, o = (0, w.h)((() => new uo(n)));
					(0, i.useEffect)((() => e && e.subscribe(o)), [o, e]), (0, i.useEffect)((() => o.addListeners()), [o])
				}))
			};

			function po(t) {
				return "string" === typeof t && t.startsWith("var(--")
			}
			const mo = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;

			function fo(t, e, n = 1) {
				const [i, o] = function(t) {
					const e = mo.exec(t);
					if (!e) return [, ];
					const [, n, i] = e;
					return [n, i]
				}(t);
				if (!i) return;
				const r = window.getComputedStyle(e).getPropertyValue(i);
				return r ? r.trim() : po(o) ? fo(o, e, n + 1) : o
			}
			const vo = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y"]),
				go = t => vo.has(t),
				yo = t => t === $ || t === tt;
			var xo;
			! function(t) {
				t.width = "width", t.height = "height", t.left = "left", t.right = "right", t.top = "top", t.bottom = "bottom"
			}(xo || (xo = {}));
			const bo = (t, e) => parseFloat(t.split(", ")[e]),
				wo = (t, e) => (n, {
					transform: i
				}) => {
					if ("none" === i || !i) return 0;
					const o = i.match(/^matrix3d\((.+)\)$/);
					if (o) return bo(o[1], e); {
						const e = i.match(/^matrix\((.+)\)$/);
						return e ? bo(e[1], t) : 0
					}
				},
				Eo = new Set(["x", "y", "z"]),
				To = B.filter((t => !Eo.has(t)));
			const Po = {
					width: ({
						x: t
					}, {
						paddingLeft: e = "0",
						paddingRight: n = "0"
					}) => t.max - t.min - parseFloat(e) - parseFloat(n),
					height: ({
						y: t
					}, {
						paddingTop: e = "0",
						paddingBottom: n = "0"
					}) => t.max - t.min - parseFloat(e) - parseFloat(n),
					top: (t, {
						top: e
					}) => parseFloat(e),
					left: (t, {
						left: e
					}) => parseFloat(e),
					bottom: ({
						y: t
					}, {
						top: e
					}) => parseFloat(e) + (t.max - t.min),
					right: ({
						x: t
					}, {
						left: e
					}) => parseFloat(e) + (t.max - t.min),
					x: wo(4, 13),
					y: wo(5, 14)
				},
				Vo = (t, e, n = {}, i = {}) => {
					e = {
						...e
					}, i = {
						...i
					};
					const o = Object.keys(e).filter(go);
					let r = [],
						s = !1;
					const a = [];
					if (o.forEach((o => {
							const l = t.getValue(o);
							if (!t.hasValue(o)) return;
							let u = n[o],
								c = Ye(u);
							const h = e[o];
							let d;
							if (Rt(h)) {
								const t = h.length,
									e = null === h[0] ? 1 : 0;
								u = h[e], c = Ye(u);
								for (let n = e; n < t; n++) d ? Ye(h[n]) : (d = Ye(h[n]), d === c || yo(c) && yo(d))
							} else d = Ye(h);
							if (c !== d)
								if (yo(c) && yo(d)) {
									const t = l.get();
									"string" === typeof t && l.set(parseFloat(t)), "string" === typeof h ? e[o] = parseFloat(h) : Array.isArray(h) && d === tt && (e[o] = h.map(parseFloat))
								} else(null === c || void 0 === c ? void 0 : c.transform) && (null === d || void 0 === d ? void 0 : d.transform) && (0 === u || 0 === h) ? 0 === u ? l.set(d.transform(u)) : e[o] = c.transform(h) : (s || (r = function(t) {
									const e = [];
									return To.forEach((n => {
										const i = t.getValue(n);
										void 0 !== i && (e.push([n, i.get()]), i.set(n.startsWith("scale") ? 1 : 0))
									})), e.length && t.render(), e
								}(t), s = !0), a.push(o), i[o] = void 0 !== i[o] ? i[o] : e[o], l.jump(h))
						})), a.length) {
						const n = a.indexOf("height") >= 0 ? window.pageYOffset : null,
							o = ((t, e, n) => {
								const i = e.measureViewportBox(),
									o = e.current,
									r = getComputedStyle(o),
									{
										display: s
									} = r,
									a = {};
								"none" === s && e.setStaticValue("display", t.display || "block"), n.forEach((t => {
									a[t] = Po[t](i, r)
								})), e.render();
								const l = e.measureViewportBox();
								return n.forEach((n => {
									const i = e.getValue(n);
									i && i.jump(a[n]), t[n] = Po[n](l, r)
								})), t
							})(e, t, a);
						return r.length && r.forEach((([e, n]) => {
							t.getValue(e).set(n)
						})), t.render(), b.j && null !== n && window.scrollTo({
							top: n
						}), {
							target: o,
							transitionEnd: i
						}
					}
					return {
						target: e,
						transitionEnd: i
					}
				};

			function Ao(t, e, n, i) {
				return (t => Object.keys(t).some(go))(e) ? Vo(t, e, n, i) : {
					target: e,
					transitionEnd: i
				}
			}
			const So = (t, e, n, i) => {
					const o = function(t, {
						...e
					}, n) {
						const i = t.current;
						if (!(i instanceof Element)) return {
							target: e,
							transitionEnd: n
						};
						n && (n = {
							...n
						}), t.values.forEach((t => {
							const e = t.get();
							if (!po(e)) return;
							const n = fo(e, i);
							n && t.set(n)
						}));
						for (const o in e) {
							const t = e[o];
							if (!po(t)) continue;
							const r = fo(t, i);
							r && (e[o] = r, n && void 0 === n[o] && (n[o] = t))
						}
						return {
							target: e,
							transitionEnd: n
						}
					}(t, e, i);
					return Ao(t, e = o.target, n, i = o.transitionEnd)
				},
				Co = {
					current: null
				},
				Mo = {
					current: !1
				};
			const Ro = Object.keys(x),
				ko = Ro.length,
				Lo = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"];
			const Do = ["initial", ...vi],
				Bo = Do.length;
			class Io extends class {
				constructor({
					parent: t,
					props: e,
					reducedMotionConfig: n,
					visualState: i
				}, o = {}) {
					this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.isPresent = !0, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
						this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
					}, this.scheduleRender = () => me.Z_.render(this.render, !1, !0);
					const {
						latestValues: r,
						renderState: s
					} = i;
					this.latestValues = r, this.baseTarget = {
						...r
					}, this.initialValues = e.initial ? {
						...r
					} : {}, this.renderState = s, this.parent = t, this.props = e, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = n, this.options = o, this.isControllingVariants = m(e), this.isVariantNode = f(e), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = Boolean(t && t.current);
					const {
						willChange: a,
						...l
					} = this.scrapeMotionValuesFromProps(e, {});
					for (const u in l) {
						const t = l[u];
						void 0 !== r[u] && O(t) && (t.set(r[u], !1), Ke(a) && a.add(u))
					}
				}
				scrapeMotionValuesFromProps(t, e) {
					return {}
				}
				mount(t) {
					var e;
					this.current = t, this.projection && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = null === (e = this.parent) || void 0 === e ? void 0 : e.addVariantChild(this)), this.values.forEach(((t, e) => this.bindToMotionValue(e, t))), Mo.current || function() {
						if (Mo.current = !0, b.j)
							if (window.matchMedia) {
								const t = window.matchMedia("(prefers-reduced-motion)"),
									e = () => Co.current = t.matches;
								t.addListener(e), e()
							} else Co.current = !1
					}(), this.shouldReduceMotion = "never" !== this.reducedMotionConfig && ("always" === this.reducedMotionConfig || Co.current), this.parent && this.parent.children.add(this), this.setProps(this.props)
				}
				unmount() {
					var t, e, n;
					null === (t = this.projection) || void 0 === t || t.unmount(), me.qY.update(this.notifyUpdate), me.qY.render(this.render), this.valueSubscriptions.forEach((t => t())), null === (e = this.removeFromVariantTree) || void 0 === e || e.call(this), null === (n = this.parent) || void 0 === n || n.children.delete(this);
					for (const i in this.events) this.events[i].clear();
					this.current = null
				}
				bindToMotionValue(t, e) {
					const n = I.has(t),
						i = e.on("change", (e => {
							this.latestValues[t] = e, this.props.onUpdate && me.Z_.update(this.notifyUpdate, !1, !0), n && this.projection && (this.projection.isTransformDirty = !0)
						})),
						o = e.on("renderRequest", this.scheduleRender);
					this.valueSubscriptions.set(t, (() => {
						i(), o()
					}))
				}
				sortNodePosition(t) {
					return this.current && this.sortInstanceNodePosition && this.type === t.type ? this.sortInstanceNodePosition(this.current, t.current) : 0
				}
				loadFeatures({
					children: t,
					...e
				}, n, o, r, s, a) {
					const l = [];
					for (let u = 0; u < ko; u++) {
						const t = Ro[u],
							{
								isEnabled: n,
								Component: o
							} = x[t];
						n(e) && o && l.push((0, i.createElement)(o, {
							key: t,
							...e,
							visualElement: this
						}))
					}
					if (!this.projection && s) {
						this.projection = new s(r, this.latestValues, this.parent && this.parent.projection);
						const {
							layoutId: t,
							layout: n,
							drag: i,
							dragConstraints: o,
							layoutScroll: l,
							layoutRoot: u
						} = e;
						this.projection.setOptions({
							layoutId: t,
							layout: n,
							alwaysMeasureLayout: Boolean(i) || o && c(o),
							visualElement: this,
							scheduleRender: () => this.scheduleRender(),
							animationType: "string" === typeof n ? n : "both",
							initialPromotionConfig: a,
							layoutScroll: l,
							layoutRoot: u
						})
					}
					return l
				}
				triggerBuild() {
					this.build(this.renderState, this.latestValues, this.options, this.props)
				}
				measureViewportBox() {
					return this.current ? this.measureInstanceViewportBox(this.current, this.props) : {
						x: {
							min: 0,
							max: 0
						},
						y: {
							min: 0,
							max: 0
						}
					}
				}
				getStaticValue(t) {
					return this.latestValues[t]
				}
				setStaticValue(t, e) {
					this.latestValues[t] = e
				}
				makeTargetAnimatable(t, e = !0) {
					return this.makeTargetAnimatableFromInstance(t, this.props, e)
				}
				setProps(t) {
					(t.transformTemplate || this.props.transformTemplate) && this.scheduleRender();
					const e = this.props;
					this.props = t;
					for (let n = 0; n < Lo.length; n++) {
						const e = Lo[n];
						this.propEventSubscriptions[e] && (this.propEventSubscriptions[e](), delete this.propEventSubscriptions[e]);
						const i = t["on" + e];
						i && (this.propEventSubscriptions[e] = this.on(e, i))
					}
					this.prevMotionValues = function(t, e, n) {
						const {
							willChange: i
						} = e;
						for (const o in e) {
							const r = e[o],
								s = n[o];
							if (O(r)) t.addValue(o, r), Ke(i) && i.add(o);
							else if (O(s)) t.addValue(o, be(r, {
								owner: t
							})), Ke(i) && i.remove(o);
							else if (s !== r)
								if (t.hasValue(o)) {
									const e = t.getValue(o);
									!e.hasAnimated && e.set(r)
								} else {
									const e = t.getStaticValue(o);
									t.addValue(o, be(void 0 !== e ? e : r, {
										owner: t
									}))
								}
						}
						for (const o in n) void 0 === e[o] && t.removeValue(o);
						return e
					}(this, this.scrapeMotionValuesFromProps(t, e), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue()
				}
				getProps() {
					return this.props
				}
				getVariant(t) {
					var e;
					return null === (e = this.props.variants) || void 0 === e ? void 0 : e[t]
				}
				getDefaultTransition() {
					return this.props.transition
				}
				getTransformPagePoint() {
					return this.props.transformPagePoint
				}
				getClosestVariantNode() {
					var t;
					return this.isVariantNode ? this : null === (t = this.parent) || void 0 === t ? void 0 : t.getClosestVariantNode()
				}
				getVariantContext(t = !1) {
					var e, n;
					if (t) return null === (e = this.parent) || void 0 === e ? void 0 : e.getVariantContext();
					if (!this.isControllingVariants) {
						const t = (null === (n = this.parent) || void 0 === n ? void 0 : n.getVariantContext()) || {};
						return void 0 !== this.props.initial && (t.initial = this.props.initial), t
					}
					const i = {};
					for (let o = 0; o < Bo; o++) {
						const t = Do[o],
							e = this.props[t];
						(h(e) || !1 === e) && (i[t] = e)
					}
					return i
				}
				addVariantChild(t) {
					var e;
					const n = this.getClosestVariantNode();
					if (n) return null === (e = n.variantChildren) || void 0 === e || e.add(t), () => n.variantChildren.delete(t)
				}
				addValue(t, e) {
					e !== this.values.get(t) && (this.removeValue(t), this.bindToMotionValue(t, e)), this.values.set(t, e), this.latestValues[t] = e.get()
				}
				removeValue(t) {
					var e;
					this.values.delete(t), null === (e = this.valueSubscriptions.get(t)) || void 0 === e || e(), this.valueSubscriptions.delete(t), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState)
				}
				hasValue(t) {
					return this.values.has(t)
				}
				getValue(t, e) {
					if (this.props.values && this.props.values[t]) return this.props.values[t];
					let n = this.values.get(t);
					return void 0 === n && void 0 !== e && (n = be(e, {
						owner: this
					}), this.addValue(t, n)), n
				}
				readValue(t) {
					return void 0 === this.latestValues[t] && this.current ? this.readValueFromInstance(this.current, t, this.options) : this.latestValues[t]
				}
				setBaseTarget(t, e) {
					this.baseTarget[t] = e
				}
				getBaseTarget(t) {
					var e;
					const {
						initial: n
					} = this.props, i = "string" === typeof n || "object" === typeof n ? null === (e = Mt(this.props, n)) || void 0 === e ? void 0 : e[t] : void 0;
					if (n && void 0 !== i) return i;
					const o = this.getBaseTargetFromProps(this.props, t);
					return void 0 === o || O(o) ? void 0 !== this.initialValues[t] && void 0 === i ? void 0 : this.baseTarget[t] : o
				}
				on(t, e) {
					return this.events[t] || (this.events[t] = new ge), this.events[t].add(e)
				}
				notify(t, ...e) {
					var n;
					null === (n = this.events[t]) || void 0 === n || n.notify(...e)
				}
			} {
				sortInstanceNodePosition(t, e) {
					return 2 & t.compareDocumentPosition(e) ? 1 : -1
				}
				getBaseTargetFromProps(t, e) {
					var n;
					return null === (n = t.style) || void 0 === n ? void 0 : n[e]
				}
				removeValueFromRenderState(t, {
					vars: e,
					style: n
				}) {
					delete e[t], delete n[t]
				}
				makeTargetAnimatableFromInstance({
					transition: t,
					transitionEnd: e,
					...n
				}, {
					transformValues: i
				}, o) {
					let r = function(t, e, n) {
						var i;
						const o = {};
						for (const r in t) {
							const t = Ge(r, e);
							o[r] = void 0 !== t ? t : null === (i = n.getValue(r)) || void 0 === i ? void 0 : i.get()
						}
						return o
					}(n, t || {}, this);
					if (i && (e && (e = i(e)), n && (n = i(n)), r && (r = i(r))), o) {
						! function(t, e, n) {
							var i, o;
							const r = Object.keys(e).filter((e => !t.hasValue(e))),
								s = r.length;
							if (s)
								for (let a = 0; a < s; a++) {
									const s = r[a],
										l = e[s];
									let u = null;
									Array.isArray(l) && (u = l[0]), null === u && (u = null !== (o = null !== (i = n[s]) && void 0 !== i ? i : t.readValue(s)) && void 0 !== o ? o : e[s]), void 0 !== u && null !== u && ("string" === typeof u && (/^\-?\d*\.?\d+$/.test(u) || de(u)) ? u = parseFloat(u) : !He(u) && Be.test(l) && (u = ze(s, l)), t.addValue(s, be(u, {
										owner: t
									})), void 0 === n[s] && (n[s] = u), null !== u && t.setBaseTarget(s, u))
								}
						}(this, n, r);
						const t = So(this, n, r, e);
						e = t.transitionEnd, n = t.target
					}
					return {
						transition: t,
						transitionEnd: e,
						...n
					}
				}
			}
			class jo extends Io {
				readValueFromInstance(t, e) {
					if (I.has(e)) {
						const t = Ne(e);
						return t && t.default || 0
					} {
						const i = (n = t, window.getComputedStyle(n)),
							o = (N(e) ? i.getPropertyValue(e) : i[e]) || 0;
						return "string" === typeof o ? o.trim() : o
					}
					var n
				}
				measureInstanceViewportBox(t, {
					transformPagePoint: e
				}) {
					return ao(t, e)
				}
				build(t, e, n, i) {
					st(t, e, n, i.transformTemplate)
				}
				scrapeMotionValuesFromProps(t, e) {
					return St(t, e)
				}
				handleChildMotionValue() {
					this.childSubscription && (this.childSubscription(), delete this.childSubscription);
					const {
						children: t
					} = this.props;
					O(t) && (this.childSubscription = t.on("change", (t => {
						this.current && (this.current.textContent = `${t}`)
					})))
				}
				renderInstance(t, e, n, i) {
					Pt(t, e, n, i)
				}
			}
			class Oo extends Io {
				constructor() {
					super(...arguments), this.isSVGTag = !1
				}
				getBaseTargetFromProps(t, e) {
					return t[e]
				}
				readValueFromInstance(t, e) {
					var n;
					return I.has(e) ? (null === (n = Ne(e)) || void 0 === n ? void 0 : n.default) || 0 : (e = Vt.has(e) ? e : Tt(e), t.getAttribute(e))
				}
				measureInstanceViewportBox() {
					return {
						x: {
							min: 0,
							max: 0
						},
						y: {
							min: 0,
							max: 0
						}
					}
				}
				scrapeMotionValuesFromProps(t, e) {
					return Ct(t, e)
				}
				build(t, e, n, i) {
					yt(t, e, n, this.isSVGTag, i.transformTemplate)
				}
				renderInstance(t, e, n, i) {
					At(t, e, 0, i)
				}
				mount(t) {
					this.isSVGTag = bt(t.tagName), super.mount(t)
				}
			}
			const Fo = (t, e) => L(t) ? new Oo(e, {
				enableHardwareAcceleration: !1
			}) : new jo(e, {
				enableHardwareAcceleration: !0
			});

			function Uo(t, e) {
				return e.max === e.min ? 0 : t / (e.max - e.min) * 100
			}
			const No = {
					correct: (t, e) => {
						if (!e.target) return t;
						if ("string" === typeof t) {
							if (!tt.test(t)) return t;
							t = parseFloat(t)
						}
						return `${Uo(t,e.target.x)}% ${Uo(t,e.target.y)}%`
					}
				},
				zo = "_$css",
				Wo = {
					correct: (t, {
						treeScale: e,
						projectionDelta: n
					}) => {
						const i = t,
							o = t.includes("var("),
							r = [];
						o && (t = t.replace(mo, (t => (r.push(t), zo))));
						const s = Be.parse(t);
						if (s.length > 5) return i;
						const a = Be.createTransformer(t),
							l = "number" !== typeof s[0] ? 1 : 0,
							u = n.x.scale * e.x,
							c = n.y.scale * e.y;
						s[0 + l] /= u, s[1 + l] /= c;
						const h = an(u, c, .5);
						"number" === typeof s[2 + l] && (s[2 + l] /= h), "number" === typeof s[3 + l] && (s[3 + l] /= h);
						let d = a(s);
						if (o) {
							let t = 0;
							d = d.replace(zo, (() => {
								const e = r[t];
								return t++, e
							}))
						}
						return d
					}
				};
			class $o extends i.Component {
				componentDidMount() {
					const {
						visualElement: t,
						layoutGroup: e,
						switchLayoutGroup: n,
						layoutId: i
					} = this.props, {
						projection: o
					} = t;
					var r;
					r = Yo, Object.assign(D, r), o && (e.group && e.group.add(o), n && n.register && i && n.register(o), o.root.didUpdate(), o.addEventListener("animationComplete", (() => {
						this.safeToRemove()
					})), o.setOptions({
						...o.options,
						onExitComplete: () => this.safeToRemove()
					})), E.hasEverUpdated = !0
				}
				getSnapshotBeforeUpdate(t) {
					const {
						layoutDependency: e,
						visualElement: n,
						drag: i,
						isPresent: o
					} = this.props, r = n.projection;
					return r ? (r.isPresent = o, i || t.layoutDependency !== e || void 0 === e ? r.willUpdate() : this.safeToRemove(), t.isPresent !== o && (o ? r.promote() : r.relegate() || me.Z_.postRender((() => {
						var t;
						(null === (t = r.getStack()) || void 0 === t ? void 0 : t.members.length) || this.safeToRemove()
					}))), null) : null
				}
				componentDidUpdate() {
					const {
						projection: t
					} = this.props.visualElement;
					t && (t.root.didUpdate(), !t.currentAnimation && t.isLead() && this.safeToRemove())
				}
				componentWillUnmount() {
					const {
						visualElement: t,
						layoutGroup: e,
						switchLayoutGroup: n
					} = this.props, {
						projection: i
					} = t;
					i && (i.scheduleCheckAfterUnmount(), (null === e || void 0 === e ? void 0 : e.group) && e.group.remove(i), (null === n || void 0 === n ? void 0 : n.deregister) && n.deregister(i))
				}
				safeToRemove() {
					const {
						safeToRemove: t
					} = this.props;
					null === t || void 0 === t || t()
				}
				render() {
					return null
				}
			}
			const Yo = {
					borderRadius: {
						...No,
						applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
					},
					borderTopLeftRadius: No,
					borderTopRightRadius: No,
					borderBottomLeftRadius: No,
					borderBottomRightRadius: No,
					boxShadow: Wo
				},
				_o = {
					measureLayout: function(t) {
						const [e, n] = ce(), o = (0, i.useContext)(P.p);
						return i.createElement($o, {
							...t,
							layoutGroup: o,
							switchLayoutGroup: (0, i.useContext)(A),
							isPresent: e,
							safeToRemove: n
						})
					}
				};
			const Ho = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
				Zo = Ho.length,
				qo = t => "string" === typeof t ? parseFloat(t) : t,
				Xo = t => "number" === typeof t || tt.test(t);

			function Go(t, e) {
				return void 0 !== t[e] ? t[e] : t.borderRadius
			}
			const Ko = Qo(0, .5, Vn),
				Jo = Qo(.5, .95, wn);

			function Qo(t, e, n) {
				return i => i < t ? 0 : i > e ? 1 : n(gn(t, e, i))
			}

			function tr(t, e) {
				t.min = e.min, t.max = e.max
			}

			function er(t, e) {
				tr(t.x, e.x), tr(t.y, e.y)
			}

			function nr(t, e, n, i, o) {
				return t = Ki(t -= e, 1 / n, i), void 0 !== o && (t = Ki(t, 1 / o, i)), t
			}

			function ir(t, e, [n, i, o], r, s) {
				! function(t, e = 0, n = 1, i = .5, o, r = t, s = t) {
					Q.test(e) && (e = parseFloat(e), e = an(s.min, s.max, e / 100) - s.min);
					if ("number" !== typeof e) return;
					let a = an(r.min, r.max, i);
					t === r && (a -= e), t.min = nr(t.min, e, n, a, o), t.max = nr(t.max, e, n, a, o)
				}(t, e[n], e[i], e[o], e.scale, r, s)
			}
			const or = ["x", "scaleX", "originX"],
				rr = ["y", "scaleY", "originY"];

			function sr(t, e, n, i) {
				ir(t.x, e, or, null === n || void 0 === n ? void 0 : n.x, null === i || void 0 === i ? void 0 : i.x), ir(t.y, e, rr, null === n || void 0 === n ? void 0 : n.y, null === i || void 0 === i ? void 0 : i.y)
			}

			function ar(t) {
				return 0 === t.translate && 1 === t.scale
			}

			function lr(t) {
				return ar(t.x) && ar(t.y)
			}

			function ur(t, e) {
				return t.x.min === e.x.min && t.x.max === e.x.max && t.y.min === e.y.min && t.y.max === e.y.max
			}

			function cr(t) {
				return Li(t.x) / Li(t.y)
			}
			class hr {
				constructor() {
					this.members = []
				}
				add(t) {
					fe(this.members, t), t.scheduleRender()
				}
				remove(t) {
					if (ve(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) {
						const t = this.members[this.members.length - 1];
						t && this.promote(t)
					}
				}
				relegate(t) {
					const e = this.members.findIndex((e => t === e));
					if (0 === e) return !1;
					let n;
					for (let i = e; i >= 0; i--) {
						const t = this.members[i];
						if (!1 !== t.isPresent) {
							n = t;
							break
						}
					}
					return !!n && (this.promote(n), !0)
				}
				promote(t, e) {
					var n;
					const i = this.lead;
					if (t !== i && (this.prevLead = i, this.lead = t, t.show(), i)) {
						i.instance && i.scheduleRender(), t.scheduleRender(), t.resumeFrom = i, e && (t.resumeFrom.preserveOpacity = !0), i.snapshot && (t.snapshot = i.snapshot, t.snapshot.latestValues = i.animationValues || i.latestValues), (null === (n = t.root) || void 0 === n ? void 0 : n.isUpdating) && (t.isLayoutDirty = !0);
						const {
							crossfade: o
						} = t.options;
						!1 === o && i.hide()
					}
				}
				exitAnimationComplete() {
					this.members.forEach((t => {
						var e, n, i, o, r;
						null === (n = (e = t.options).onExitComplete) || void 0 === n || n.call(e), null === (r = null === (i = t.resumingFrom) || void 0 === i ? void 0 : (o = i.options).onExitComplete) || void 0 === r || r.call(o)
					}))
				}
				scheduleRender() {
					this.members.forEach((t => {
						t.instance && t.scheduleRender(!1)
					}))
				}
				removeLeadSnapshot() {
					this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
				}
			}

			function dr(t, e, n) {
				let i = "";
				const o = t.x.translate / e.x,
					r = t.y.translate / e.y;
				if ((o || r) && (i = `translate3d(${o}px, ${r}px, 0) `), 1 === e.x && 1 === e.y || (i += `scale(${1/e.x}, ${1/e.y}) `), n) {
					const {
						rotate: t,
						rotateX: e,
						rotateY: o
					} = n;
					t && (i += `rotate(${t}deg) `), e && (i += `rotateX(${e}deg) `), o && (i += `rotateY(${o}deg) `)
				}
				const s = t.x.scale * e.x,
					a = t.y.scale * e.y;
				return 1 === s && 1 === a || (i += `scale(${s}, ${a})`), i || "none"
			}
			const pr = (t, e) => t.depth - e.depth;
			class mr {
				constructor() {
					this.children = [], this.isDirty = !1
				}
				add(t) {
					fe(this.children, t), this.isDirty = !0
				}
				remove(t) {
					ve(this.children, t), this.isDirty = !0
				}
				forEach(t) {
					this.isDirty && this.children.sort(pr), this.isDirty = !1, this.children.forEach(t)
				}
			}
			const fr = ["", "X", "Y", "Z"];
			let vr = 0;

			function gr({
				attachResizeListener: t,
				defaultParent: e,
				measureScroll: n,
				checkIsScrollRoot: i,
				resetTransform: o
			}) {
				return class {
					constructor(t, n = {}, i = (null === e || void 0 === e ? void 0 : e())) {
						this.id = vr++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isTransformDirty = !1, this.isProjectionDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = {
							x: 1,
							y: 1
						}, this.eventHandlers = new Map, this.potentialNodes = new Map, this.checkUpdateFailed = () => {
							this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots())
						}, this.updateProjection = () => {
							this.nodes.forEach(br), this.nodes.forEach(Vr), this.nodes.forEach(Ar)
						}, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.elementId = t, this.latestValues = n, this.root = i ? i.root || i : this, this.path = i ? [...i.path, i] : [], this.parent = i, this.depth = i ? i.depth + 1 : 0, t && this.root.registerPotentialNode(t, this);
						for (let e = 0; e < this.path.length; e++) this.path[e].shouldResetTransform = !0;
						this.root === this && (this.nodes = new mr)
					}
					addEventListener(t, e) {
						return this.eventHandlers.has(t) || this.eventHandlers.set(t, new ge), this.eventHandlers.get(t).add(e)
					}
					notifyListeners(t, ...e) {
						const n = this.eventHandlers.get(t);
						null === n || void 0 === n || n.notify(...e)
					}
					hasListeners(t) {
						return this.eventHandlers.has(t)
					}
					registerPotentialNode(t, e) {
						this.potentialNodes.set(t, e)
					}
					mount(e, n = !1) {
						var i;
						if (this.instance) return;
						this.isSVG = e instanceof SVGElement && "svg" !== e.tagName, this.instance = e;
						const {
							layoutId: o,
							layout: r,
							visualElement: s
						} = this.options;
						if (s && !s.current && s.mount(e), this.root.nodes.add(this), null === (i = this.parent) || void 0 === i || i.children.add(this), this.elementId && this.root.potentialNodes.delete(this.elementId), n && (r || o) && (this.isLayoutDirty = !0), t) {
							let n;
							const i = () => this.root.updateBlockedByResize = !1;
							t(e, (() => {
								this.root.updateBlockedByResize = !0, n && n(), n = Qn(i, 250), E.hasAnimatedSinceResize && (E.hasAnimatedSinceResize = !1, this.nodes.forEach(Pr))
							}))
						}
						o && this.root.registerSharedNode(o, this), !1 !== this.options.animate && s && (o || r) && this.addEventListener("didUpdate", (({
							delta: t,
							hasLayoutChanged: e,
							hasRelativeTargetChanged: n,
							layout: i
						}) => {
							var o, r, a, l, u;
							if (this.isTreeAnimationBlocked()) return this.target = void 0, void(this.relativeTarget = void 0);
							const c = null !== (r = null !== (o = this.options.transition) && void 0 !== o ? o : s.getDefaultTransition()) && void 0 !== r ? r : Lr,
								{
									onLayoutAnimationStart: h,
									onLayoutAnimationComplete: d
								} = s.getProps(),
								p = !this.targetLayout || !ur(this.targetLayout, i) || n,
								m = !e && n;
							if (this.options.layoutRoot || (null === (a = this.resumeFrom) || void 0 === a ? void 0 : a.instance) || m || e && (p || !this.currentAnimation)) {
								this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(t, m);
								const e = {
									...ci(c, "layout"),
									onPlay: h,
									onComplete: d
								};
								(s.shouldReduceMotion || this.options.layoutRoot) && (e.delay = 0, e.type = !1), this.startAnimation(e)
							} else e || 0 !== this.animationProgress || Pr(this), this.isLead() && (null === (u = (l = this.options).onExitComplete) || void 0 === u || u.call(l));
							this.targetLayout = i
						}))
					}
					unmount() {
						var t, e;
						this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this), null === (t = this.getStack()) || void 0 === t || t.remove(this), null === (e = this.parent) || void 0 === e || e.children.delete(this), this.instance = void 0, me.qY.preRender(this.updateProjection)
					}
					blockUpdate() {
						this.updateManuallyBlocked = !0
					}
					unblockUpdate() {
						this.updateManuallyBlocked = !1
					}
					isUpdateBlocked() {
						return this.updateManuallyBlocked || this.updateBlockedByResize
					}
					isTreeAnimationBlocked() {
						var t;
						return this.isAnimationBlocked || (null === (t = this.parent) || void 0 === t ? void 0 : t.isTreeAnimationBlocked()) || !1
					}
					startUpdate() {
						var t;
						this.isUpdateBlocked() || (this.isUpdating = !0, null === (t = this.nodes) || void 0 === t || t.forEach(Sr), this.animationId++)
					}
					getTransformTemplate() {
						var t;
						return null === (t = this.options.visualElement) || void 0 === t ? void 0 : t.getProps().transformTemplate
					}
					willUpdate(t = !0) {
						var e, n, i;
						if (this.root.isUpdateBlocked()) return void(null === (n = (e = this.options).onExitComplete) || void 0 === n || n.call(e));
						if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return;
						this.isLayoutDirty = !0;
						for (let s = 0; s < this.path.length; s++) {
							const t = this.path[s];
							t.shouldResetTransform = !0, t.updateScroll("snapshot"), t.options.layoutRoot && t.willUpdate(!1)
						}
						const {
							layoutId: o,
							layout: r
						} = this.options;
						(void 0 !== o || r) && (this.prevTransformTemplateValue = null === (i = this.getTransformTemplate()) || void 0 === i ? void 0 : i(this.latestValues, ""), this.updateSnapshot(), t && this.notifyListeners("willUpdate"))
					}
					didUpdate() {
						if (this.isUpdateBlocked()) return this.unblockUpdate(), this.clearAllSnapshots(), void this.nodes.forEach(Er);
						this.isUpdating && (this.isUpdating = !1, this.potentialNodes.size && (this.potentialNodes.forEach(Dr), this.potentialNodes.clear()), this.nodes.forEach(Tr), this.nodes.forEach(yr), this.nodes.forEach(xr), this.clearAllSnapshots(), me.iW.update(), me.iW.preRender(), me.iW.render())
					}
					clearAllSnapshots() {
						this.nodes.forEach(wr), this.sharedNodes.forEach(Cr)
					}
					scheduleUpdateProjection() {
						me.Z_.preRender(this.updateProjection, !1, !0)
					}
					scheduleCheckAfterUnmount() {
						me.Z_.postRender((() => {
							this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
						}))
					}
					updateSnapshot() {
						!this.snapshot && this.instance && (this.snapshot = this.measure())
					}
					updateLayout() {
						var t;
						if (!this.instance) return;
						if (this.updateScroll(), (!this.options.alwaysMeasureLayout || !this.isLead()) && !this.isLayoutDirty) return;
						if (this.resumeFrom && !this.resumeFrom.instance)
							for (let n = 0; n < this.path.length; n++) {
								this.path[n].updateScroll()
							}
						const e = this.layout;
						this.layout = this.measure(!1), this.layoutCorrected = {
							x: {
								min: 0,
								max: 0
							},
							y: {
								min: 0,
								max: 0
							}
						}, this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox), null === (t = this.options.visualElement) || void 0 === t || t.notify("LayoutMeasure", this.layout.layoutBox, null === e || void 0 === e ? void 0 : e.layoutBox)
					}
					updateScroll(t = "measure") {
						let e = Boolean(this.options.layoutScroll && this.instance);
						this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === t && (e = !1), e && (this.scroll = {
							animationId: this.root.animationId,
							phase: t,
							isRoot: i(this.instance),
							offset: n(this.instance)
						})
					}
					resetTransform() {
						var t;
						if (!o) return;
						const e = this.isLayoutDirty || this.shouldResetTransform,
							n = this.projectionDelta && !lr(this.projectionDelta),
							i = null === (t = this.getTransformTemplate()) || void 0 === t ? void 0 : t(this.latestValues, ""),
							r = i !== this.prevTransformTemplateValue;
						e && (n || qi(this.latestValues) || r) && (o(this.instance, i), this.shouldResetTransform = !1, this.scheduleRender())
					}
					measure(t = !0) {
						const e = this.measurePageBox();
						let n = this.removeElementScroll(e);
						var i;
						return t && (n = this.removeTransform(n)), Br((i = n).x), Br(i.y), {
							animationId: this.root.animationId,
							measuredBox: e,
							layoutBox: n,
							latestValues: {},
							source: this.id
						}
					}
					measurePageBox() {
						const {
							visualElement: t
						} = this.options;
						if (!t) return {
							x: {
								min: 0,
								max: 0
							},
							y: {
								min: 0,
								max: 0
							}
						};
						const e = t.measureViewportBox(),
							{
								scroll: n
							} = this.root;
						return n && (no(e.x, n.offset.x), no(e.y, n.offset.y)), e
					}
					removeElementScroll(t) {
						const e = {
							x: {
								min: 0,
								max: 0
							},
							y: {
								min: 0,
								max: 0
							}
						};
						er(e, t);
						for (let n = 0; n < this.path.length; n++) {
							const i = this.path[n],
								{
									scroll: o,
									options: r
								} = i;
							if (i !== this.root && o && r.layoutScroll) {
								if (o.isRoot) {
									er(e, t);
									const {
										scroll: n
									} = this.root;
									n && (no(e.x, -n.offset.x), no(e.y, -n.offset.y))
								}
								no(e.x, o.offset.x), no(e.y, o.offset.y)
							}
						}
						return e
					}
					applyTransform(t, e = !1) {
						const n = {
							x: {
								min: 0,
								max: 0
							},
							y: {
								min: 0,
								max: 0
							}
						};
						er(n, t);
						for (let i = 0; i < this.path.length; i++) {
							const t = this.path[i];
							!e && t.options.layoutScroll && t.scroll && t !== t.root && so(n, {
								x: -t.scroll.offset.x,
								y: -t.scroll.offset.y
							}), qi(t.latestValues) && so(n, t.latestValues)
						}
						return qi(this.latestValues) && so(n, this.latestValues), n
					}
					removeTransform(t) {
						var e;
						const n = {
							x: {
								min: 0,
								max: 0
							},
							y: {
								min: 0,
								max: 0
							}
						};
						er(n, t);
						for (let i = 0; i < this.path.length; i++) {
							const t = this.path[i];
							if (!t.instance) continue;
							if (!qi(t.latestValues)) continue;
							Zi(t.latestValues) && t.updateSnapshot();
							const o = {
								x: {
									min: 0,
									max: 0
								},
								y: {
									min: 0,
									max: 0
								}
							};
							er(o, t.measurePageBox()), sr(n, t.latestValues, null === (e = t.snapshot) || void 0 === e ? void 0 : e.layoutBox, o)
						}
						return qi(this.latestValues) && sr(n, this.latestValues), n
					}
					setTargetDelta(t) {
						this.targetDelta = t, this.isProjectionDirty = !0, this.root.scheduleUpdateProjection()
					}
					setOptions(t) {
						this.options = {
							...this.options,
							...t,
							crossfade: void 0 === t.crossfade || t.crossfade
						}
					}
					clearMeasurements() {
						this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1
					}
					resolveTargetDelta() {
						var t;
						const e = this.getLead();
						if (this.isProjectionDirty || (this.isProjectionDirty = e.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = e.isTransformDirty), !this.isProjectionDirty && !this.attemptToResolveRelativeTarget) return;
						const {
							layout: n,
							layoutId: i
						} = this.options;
						if (this.layout && (n || i)) {
							if (!this.targetDelta && !this.relativeTarget) {
								const t = this.getClosestProjectingParent();
								t && t.layout ? (this.relativeParent = t, this.relativeTarget = {
									x: {
										min: 0,
										max: 0
									},
									y: {
										min: 0,
										max: 0
									}
								}, this.relativeTargetOrigin = {
									x: {
										min: 0,
										max: 0
									},
									y: {
										min: 0,
										max: 0
									}
								}, Fi(this.relativeTargetOrigin, this.layout.layoutBox, t.layout.layoutBox), er(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
							}
							var o, r, s;
							if (this.relativeTarget || this.targetDelta)
								if (this.target || (this.target = {
										x: {
											min: 0,
											max: 0
										},
										y: {
											min: 0,
											max: 0
										}
									}, this.targetWithTransforms = {
										x: {
											min: 0,
											max: 0
										},
										y: {
											min: 0,
											max: 0
										}
									}), this.relativeTarget && this.relativeTargetOrigin && (null === (t = this.relativeParent) || void 0 === t ? void 0 : t.target) ? (o = this.target, r = this.relativeTarget, s = this.relativeParent.target, ji(o.x, r.x, s.x), ji(o.y, r.y, s.y)) : this.targetDelta ? (Boolean(this.resumingFrom) ? this.target = this.applyTransform(this.layout.layoutBox) : er(this.target, this.layout.layoutBox), to(this.target, this.targetDelta)) : er(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
									this.attemptToResolveRelativeTarget = !1;
									const t = this.getClosestProjectingParent();
									t && Boolean(t.resumingFrom) === Boolean(this.resumingFrom) && !t.options.layoutScroll && t.target ? (this.relativeParent = t, this.relativeTarget = {
										x: {
											min: 0,
											max: 0
										},
										y: {
											min: 0,
											max: 0
										}
									}, this.relativeTargetOrigin = {
										x: {
											min: 0,
											max: 0
										},
										y: {
											min: 0,
											max: 0
										}
									}, Fi(this.relativeTargetOrigin, this.target, t.target), er(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
								}
						}
					}
					getClosestProjectingParent() {
						if (this.parent && !Zi(this.parent.latestValues) && !Xi(this.parent.latestValues)) return (this.parent.relativeTarget || this.parent.targetDelta || this.parent.options.layoutRoot) && this.parent.layout ? this.parent : this.parent.getClosestProjectingParent()
					}
					calcProjection() {
						var t;
						const {
							isProjectionDirty: e,
							isTransformDirty: n
						} = this;
						this.isProjectionDirty = this.isTransformDirty = !1;
						const i = this.getLead(),
							o = Boolean(this.resumingFrom) || this !== i;
						let r = !0;
						if (e && (r = !1), o && n && (r = !1), r) return;
						const {
							layout: s,
							layoutId: a
						} = this.options;
						if (this.isTreeAnimating = Boolean((null === (t = this.parent) || void 0 === t ? void 0 : t.isTreeAnimating) || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !s && !a) return;
						er(this.layoutCorrected, this.layout.layoutBox),
							function(t, e, n, i = !1) {
								var o, r;
								const s = n.length;
								if (!s) return;
								let a, l;
								e.x = e.y = 1;
								for (let u = 0; u < s; u++) a = n[u], l = a.projectionDelta, "contents" !== (null === (r = null === (o = a.instance) || void 0 === o ? void 0 : o.style) || void 0 === r ? void 0 : r.display) && (i && a.options.layoutScroll && a.scroll && a !== a.root && so(t, {
									x: -a.scroll.offset.x,
									y: -a.scroll.offset.y
								}), l && (e.x *= l.x.scale, e.y *= l.y.scale, to(t, l)), i && qi(a.latestValues) && so(t, a.latestValues));
								e.x = eo(e.x), e.y = eo(e.y)
							}(this.layoutCorrected, this.treeScale, this.path, o);
						const {
							target: l
						} = i;
						if (!l) return;
						this.projectionDelta || (this.projectionDelta = {
							x: {
								translate: 0,
								scale: 1,
								origin: 0,
								originPoint: 0
							},
							y: {
								translate: 0,
								scale: 1,
								origin: 0,
								originPoint: 0
							}
						}, this.projectionDeltaWithTransform = {
							x: {
								translate: 0,
								scale: 1,
								origin: 0,
								originPoint: 0
							},
							y: {
								translate: 0,
								scale: 1,
								origin: 0,
								originPoint: 0
							}
						});
						const u = this.treeScale.x,
							c = this.treeScale.y,
							h = this.projectionTransform;
						Ii(this.projectionDelta, this.layoutCorrected, l, this.latestValues), this.projectionTransform = dr(this.projectionDelta, this.treeScale), this.projectionTransform === h && this.treeScale.x === u && this.treeScale.y === c || (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", l))
					}
					hide() {
						this.isVisible = !1
					}
					show() {
						this.isVisible = !0
					}
					scheduleRender(t = !0) {
						var e, n, i;
						null === (n = (e = this.options).scheduleRender) || void 0 === n || n.call(e), t && (null === (i = this.getStack()) || void 0 === i || i.scheduleRender()), this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
					}
					setAnimationOrigin(t, e = !1) {
						var n, i;
						const o = this.snapshot,
							r = (null === o || void 0 === o ? void 0 : o.latestValues) || {},
							s = {
								...this.latestValues
							},
							a = {
								x: {
									translate: 0,
									scale: 1,
									origin: 0,
									originPoint: 0
								},
								y: {
									translate: 0,
									scale: 1,
									origin: 0,
									originPoint: 0
								}
							};
						this.relativeParent && this.relativeParent.options.layoutRoot || (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !e;
						const l = {
								x: {
									min: 0,
									max: 0
								},
								y: {
									min: 0,
									max: 0
								}
							},
							u = (null === o || void 0 === o ? void 0 : o.source) !== (null === (n = this.layout) || void 0 === n ? void 0 : n.source),
							c = ((null === (i = this.getStack()) || void 0 === i ? void 0 : i.members.length) || 0) <= 1,
							h = Boolean(u && !c && !0 === this.options.crossfade && !this.path.some(kr));
						this.animationProgress = 0, this.mixTargetDelta = e => {
							var n;
							const i = e / 1e3;
							var o, d, p, m;
							Mr(a.x, t.x, i), Mr(a.y, t.y, i), this.setTargetDelta(a), this.relativeTarget && this.relativeTargetOrigin && this.layout && (null === (n = this.relativeParent) || void 0 === n ? void 0 : n.layout) && (Fi(l, this.layout.layoutBox, this.relativeParent.layout.layoutBox), o = this.relativeTarget, d = this.relativeTargetOrigin, p = l, m = i, Rr(o.x, d.x, p.x, m), Rr(o.y, d.y, p.y, m)), u && (this.animationValues = s, function(t, e, n, i, o, r) {
								o ? (t.opacity = an(0, void 0 !== n.opacity ? n.opacity : 1, Ko(i)), t.opacityExit = an(void 0 !== e.opacity ? e.opacity : 1, 0, Jo(i))) : r && (t.opacity = an(void 0 !== e.opacity ? e.opacity : 1, void 0 !== n.opacity ? n.opacity : 1, i));
								for (let s = 0; s < Zo; s++) {
									const o = `border${Ho[s]}Radius`;
									let r = Go(e, o),
										a = Go(n, o);
									void 0 === r && void 0 === a || (r || (r = 0), a || (a = 0), 0 === r || 0 === a || Xo(r) === Xo(a) ? (t[o] = Math.max(an(qo(r), qo(a), i), 0), (Q.test(a) || Q.test(r)) && (t[o] += "%")) : t[o] = a)
								}(e.rotate || n.rotate) && (t.rotate = an(e.rotate || 0, n.rotate || 0, i))
							}(s, r, this.latestValues, i, h, c)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = i
						}, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
					}
					startAnimation(t) {
						var e, n;
						this.notifyListeners("animationStart"), null === (e = this.currentAnimation) || void 0 === e || e.stop(), this.resumingFrom && (null === (n = this.resumingFrom.currentAnimation) || void 0 === n || n.stop()), this.pendingAnimation && (me.qY.update(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = me.Z_.update((() => {
							E.hasAnimatedSinceResize = !0, this.currentAnimation = function(t, e, n = {}) {
								const i = O(t) ? t : be(t);
								return i.start(hi("", i, e, n)), {
									stop: () => i.stop(),
									isAnimating: () => i.isAnimating()
								}
							}(0, 1e3, {
								...t,
								onUpdate: e => {
									var n;
									this.mixTargetDelta(e), null === (n = t.onUpdate) || void 0 === n || n.call(t, e)
								},
								onComplete: () => {
									var e;
									null === (e = t.onComplete) || void 0 === e || e.call(t), this.completeAnimation()
								}
							}), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0
						}))
					}
					completeAnimation() {
						var t;
						this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0), null === (t = this.getStack()) || void 0 === t || t.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete")
					}
					finishAnimation() {
						var t;
						this.currentAnimation && (null === (t = this.mixTargetDelta) || void 0 === t || t.call(this, 1e3), this.currentAnimation.stop()), this.completeAnimation()
					}
					applyTransformsToTarget() {
						const t = this.getLead();
						let {
							targetWithTransforms: e,
							target: n,
							layout: i,
							latestValues: o
						} = t;
						if (e && n && i) {
							if (this !== t && this.layout && i && Ir(this.options.animationType, this.layout.layoutBox, i.layoutBox)) {
								n = this.target || {
									x: {
										min: 0,
										max: 0
									},
									y: {
										min: 0,
										max: 0
									}
								};
								const e = Li(this.layout.layoutBox.x);
								n.x.min = t.target.x.min, n.x.max = n.x.min + e;
								const i = Li(this.layout.layoutBox.y);
								n.y.min = t.target.y.min, n.y.max = n.y.min + i
							}
							er(e, n), so(e, o), Ii(this.projectionDeltaWithTransform, this.layoutCorrected, e, o)
						}
					}
					registerSharedNode(t, e) {
						var n, i, o;
						this.sharedNodes.has(t) || this.sharedNodes.set(t, new hr);
						this.sharedNodes.get(t).add(e), e.promote({
							transition: null === (n = e.options.initialPromotionConfig) || void 0 === n ? void 0 : n.transition,
							preserveFollowOpacity: null === (o = null === (i = e.options.initialPromotionConfig) || void 0 === i ? void 0 : i.shouldPreserveFollowOpacity) || void 0 === o ? void 0 : o.call(i, e)
						})
					}
					isLead() {
						const t = this.getStack();
						return !t || t.lead === this
					}
					getLead() {
						var t;
						const {
							layoutId: e
						} = this.options;
						return e && (null === (t = this.getStack()) || void 0 === t ? void 0 : t.lead) || this
					}
					getPrevLead() {
						var t;
						const {
							layoutId: e
						} = this.options;
						return e ? null === (t = this.getStack()) || void 0 === t ? void 0 : t.prevLead : void 0
					}
					getStack() {
						const {
							layoutId: t
						} = this.options;
						if (t) return this.root.sharedNodes.get(t)
					}
					promote({
						needsReset: t,
						transition: e,
						preserveFollowOpacity: n
					} = {}) {
						const i = this.getStack();
						i && i.promote(this, n), t && (this.projectionDelta = void 0, this.needsReset = !0), e && this.setOptions({
							transition: e
						})
					}
					relegate() {
						const t = this.getStack();
						return !!t && t.relegate(this)
					}
					resetRotation() {
						const {
							visualElement: t
						} = this.options;
						if (!t) return;
						let e = !1;
						const {
							latestValues: n
						} = t;
						if ((n.rotate || n.rotateX || n.rotateY || n.rotateZ) && (e = !0), !e) return;
						const i = {};
						for (let o = 0; o < fr.length; o++) {
							const e = "rotate" + fr[o];
							n[e] && (i[e] = n[e], t.setStaticValue(e, 0))
						}
						null === t || void 0 === t || t.render();
						for (const o in i) t.setStaticValue(o, i[o]);
						t.scheduleRender()
					}
					getProjectionStyles(t = {}) {
						var e, n;
						const i = {};
						if (!this.instance || this.isSVG) return i;
						if (!this.isVisible) return {
							visibility: "hidden"
						};
						i.visibility = "";
						const o = this.getTransformTemplate();
						if (this.needsReset) return this.needsReset = !1, i.opacity = "", i.pointerEvents = kt(t.pointerEvents) || "", i.transform = o ? o(this.latestValues, "") : "none", i;
						const r = this.getLead();
						if (!this.projectionDelta || !this.layout || !r.target) {
							const e = {};
							return this.options.layoutId && (e.opacity = void 0 !== this.latestValues.opacity ? this.latestValues.opacity : 1, e.pointerEvents = kt(t.pointerEvents) || ""), this.hasProjected && !qi(this.latestValues) && (e.transform = o ? o({}, "") : "none", this.hasProjected = !1), e
						}
						const s = r.animationValues || r.latestValues;
						this.applyTransformsToTarget(), i.transform = dr(this.projectionDeltaWithTransform, this.treeScale, s), o && (i.transform = o(s, i.transform));
						const {
							x: a,
							y: l
						} = this.projectionDelta;
						i.transformOrigin = `${100*a.origin}% ${100*l.origin}% 0`, r.animationValues ? i.opacity = r === this ? null !== (n = null !== (e = s.opacity) && void 0 !== e ? e : this.latestValues.opacity) && void 0 !== n ? n : 1 : this.preserveOpacity ? this.latestValues.opacity : s.opacityExit : i.opacity = r === this ? void 0 !== s.opacity ? s.opacity : "" : void 0 !== s.opacityExit ? s.opacityExit : 0;
						for (const u in D) {
							if (void 0 === s[u]) continue;
							const {
								correct: t,
								applyTo: e
							} = D[u], n = "none" === i.transform ? s[u] : t(s[u], r);
							if (e) {
								const t = e.length;
								for (let o = 0; o < t; o++) i[e[o]] = n
							} else i[u] = n
						}
						return this.options.layoutId && (i.pointerEvents = r === this ? kt(t.pointerEvents) || "" : "none"), i
					}
					clearSnapshot() {
						this.resumeFrom = this.snapshot = void 0
					}
					resetTree() {
						this.root.nodes.forEach((t => {
							var e;
							return null === (e = t.currentAnimation) || void 0 === e ? void 0 : e.stop()
						})), this.root.nodes.forEach(Er), this.root.sharedNodes.clear()
					}
				}
			}

			function yr(t) {
				t.updateLayout()
			}

			function xr(t) {
				var e, n, i;
				const o = (null === (e = t.resumeFrom) || void 0 === e ? void 0 : e.snapshot) || t.snapshot;
				if (t.isLead() && t.layout && o && t.hasListeners("didUpdate")) {
					const {
						layoutBox: e,
						measuredBox: n
					} = t.layout, {
						animationType: i
					} = t.options, r = o.source !== t.layout.source;
					"size" === i ? Yi((t => {
						const n = r ? o.measuredBox[t] : o.layoutBox[t],
							i = Li(n);
						n.min = e[t].min, n.max = n.min + i
					})) : Ir(i, o.layoutBox, e) && Yi((t => {
						const n = r ? o.measuredBox[t] : o.layoutBox[t],
							i = Li(e[t]);
						n.max = n.min + i
					}));
					const s = {
						x: {
							translate: 0,
							scale: 1,
							origin: 0,
							originPoint: 0
						},
						y: {
							translate: 0,
							scale: 1,
							origin: 0,
							originPoint: 0
						}
					};
					Ii(s, e, o.layoutBox);
					const a = {
						x: {
							translate: 0,
							scale: 1,
							origin: 0,
							originPoint: 0
						},
						y: {
							translate: 0,
							scale: 1,
							origin: 0,
							originPoint: 0
						}
					};
					r ? Ii(a, t.applyTransform(n, !0), o.measuredBox) : Ii(a, e, o.layoutBox);
					const l = !lr(s);
					let u = !1;
					if (!t.resumeFrom) {
						const n = t.getClosestProjectingParent();
						if (n && !n.resumeFrom) {
							const {
								snapshot: i,
								layout: r
							} = n;
							if (i && r) {
								const s = {
									x: {
										min: 0,
										max: 0
									},
									y: {
										min: 0,
										max: 0
									}
								};
								Fi(s, o.layoutBox, i.layoutBox);
								const a = {
									x: {
										min: 0,
										max: 0
									},
									y: {
										min: 0,
										max: 0
									}
								};
								Fi(a, e, r.layoutBox), ur(s, a) || (u = !0), n.options.layoutRoot && (t.relativeTarget = a, t.relativeTargetOrigin = s, t.relativeParent = n)
							}
						}
					}
					t.notifyListeners("didUpdate", {
						layout: e,
						snapshot: o,
						delta: a,
						layoutDelta: s,
						hasLayoutChanged: l,
						hasRelativeTargetChanged: u
					})
				} else t.isLead() && (null === (i = (n = t.options).onExitComplete) || void 0 === i || i.call(n));
				t.options.transition = void 0
			}

			function br(t) {
				t.isProjectionDirty || (t.isProjectionDirty = Boolean(t.parent && t.parent.isProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = Boolean(t.parent && t.parent.isTransformDirty))
			}

			function wr(t) {
				t.clearSnapshot()
			}

			function Er(t) {
				t.clearMeasurements()
			}

			function Tr(t) {
				const {
					visualElement: e
				} = t.options;
				(null === e || void 0 === e ? void 0 : e.getProps().onBeforeLayoutMeasure) && e.notify("BeforeLayoutMeasure"), t.resetTransform()
			}

			function Pr(t) {
				t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0
			}

			function Vr(t) {
				t.resolveTargetDelta()
			}

			function Ar(t) {
				t.calcProjection()
			}

			function Sr(t) {
				t.resetRotation()
			}

			function Cr(t) {
				t.removeLeadSnapshot()
			}

			function Mr(t, e, n) {
				t.translate = an(e.translate, 0, n), t.scale = an(e.scale, 1, n), t.origin = e.origin, t.originPoint = e.originPoint
			}

			function Rr(t, e, n, i) {
				t.min = an(e.min, n.min, i), t.max = an(e.max, n.max, i)
			}

			function kr(t) {
				return t.animationValues && void 0 !== t.animationValues.opacityExit
			}
			const Lr = {
				duration: .45,
				ease: [.4, 0, .1, 1]
			};

			function Dr(t, e) {
				let n = t.root;
				for (let o = t.path.length - 1; o >= 0; o--)
					if (Boolean(t.path[o].instance)) {
						n = t.path[o];
						break
					} const i = (n && n !== t.root ? n.instance : document).querySelector(`[data-projection-id="${e}"]`);
				i && t.mount(i, !0)
			}

			function Br(t) {
				t.min = Math.round(t.min), t.max = Math.round(t.max)
			}

			function Ir(t, e, n) {
				return "position" === t || "preserve-aspect" === t && !Di(cr(e), cr(n), .2)
			}
			const jr = gr({
					attachResizeListener: (t, e) => Ot(t, "resize", e),
					measureScroll: () => ({
						x: document.documentElement.scrollLeft || document.body.scrollLeft,
						y: document.documentElement.scrollTop || document.body.scrollTop
					}),
					checkIsScrollRoot: () => !0
				}),
				Or = {
					current: void 0
				},
				Fr = gr({
					measureScroll: t => ({
						x: t.scrollLeft,
						y: t.scrollTop
					}),
					defaultParent: () => {
						if (!Or.current) {
							const t = new jr(0, {});
							t.mount(window), t.setOptions({
								layoutScroll: !0
							}), Or.current = t
						}
						return Or.current
					},
					resetTransform: (t, e) => {
						t.style.transform = void 0 !== e ? e : "none"
					},
					checkIsScrollRoot: t => Boolean("fixed" === window.getComputedStyle(t).position)
				}),
				Ur = {
					...Ti,
					...ue,
					...ho,
					..._o
				},
				Nr = R(((t, e) => function(t, {
					forwardMotionProps: e = !1
				}, n, i, o) {
					return {
						...L(t) ? Bt : It,
						preloadedFeatures: n,
						useRender: Et(e),
						createVisualElement: i,
						projectionNodeConstructor: o,
						Component: t
					}
				}(t, e, Ur, Fo, Fr)))
		},
		6949: function(t, e, n) {
			"use strict";
			n.d(e, {
				j: function() {
					return i
				}
			});
			const i = "undefined" !== typeof document
		},
		2308: function(t, e, n) {
			"use strict";
			n.d(e, {
				h: function() {
					return o
				}
			});
			var i = n(7378);

			function o(t) {
				const e = (0, i.useRef)(null);
				return null === e.current && (e.current = t()), e.current
			}
		},
		4306: function(t, e, n) {
			"use strict";
			n.d(e, {
				L: function() {
					return o
				}
			});
			var i = n(7378);
			const o = n(6949).j ? i.useLayoutEffect : i.useEffect
		},
		9929: function(t, e, n) {
			"use strict";
			n.d(e, {
				z: function() {
					return o
				}
			});
			var i = n(7378);

			function o(t) {
				return (0, i.useEffect)((() => () => t()), [])
			}
		},
		9689: function(t, e, n) {
			"use strict";
			n.d(e, {
				YD: function() {
					return c
				}
			});
			var i = n(7378);
			const o = new Map,
				r = new WeakMap;
			let s, a = 0;

			function l(t) {
				return Object.keys(t).sort().filter((e => void 0 !== t[e])).map((e => {
					return `${e}_${"root"===e?(n=t.root,n?(r.has(n)||(a+=1,r.set(n,a.toString())),r.get(n)):"0"):t[e]}`;
					var n
				})).toString()
			}

			function u(t, e, n = {}, i = s) {
				if ("undefined" === typeof window.IntersectionObserver && void 0 !== i) {
					const o = t.getBoundingClientRect();
					return e(i, {
						isIntersecting: i,
						target: t,
						intersectionRatio: "number" === typeof n.threshold ? n.threshold : 0,
						time: 0,
						boundingClientRect: o,
						intersectionRect: o,
						rootBounds: o
					}), () => {}
				}
				const {
					id: r,
					observer: a,
					elements: u
				} = function(t) {
					let e = l(t),
						n = o.get(e);
					if (!n) {
						const i = new Map;
						let r;
						const s = new IntersectionObserver((e => {
							e.forEach((e => {
								var n;
								const o = e.isIntersecting && r.some((t => e.intersectionRatio >= t));
								t.trackVisibility && "undefined" === typeof e.isVisible && (e.isVisible = o), null == (n = i.get(e.target)) || n.forEach((t => {
									t(o, e)
								}))
							}))
						}), t);
						r = s.thresholds || (Array.isArray(t.threshold) ? t.threshold : [t.threshold || 0]), n = {
							id: e,
							observer: s,
							elements: i
						}, o.set(e, n)
					}
					return n
				}(n);
				let c = u.get(t) || [];
				return u.has(t) || u.set(t, c), c.push(e), a.observe(t),
					function() {
						c.splice(c.indexOf(e), 1), 0 === c.length && (u.delete(t), a.unobserve(t)), 0 === u.size && (a.disconnect(), o.delete(r))
					}
			}
			i.Component;

			function c({
				threshold: t,
				delay: e,
				trackVisibility: n,
				rootMargin: o,
				root: r,
				triggerOnce: s,
				skip: a,
				initialInView: l,
				fallbackInView: c,
				onChange: h
			} = {}) {
				var d;
				const [p, m] = i.useState(null), f = i.useRef(), [v, g] = i.useState({
					inView: !!l,
					entry: void 0
				});
				f.current = h, i.useEffect((() => {
					if (a || !p) return;
					let i;
					return i = u(p, ((t, e) => {
						g({
							inView: t,
							entry: e
						}), f.current && f.current(t, e), e.isIntersecting && s && i && (i(), i = void 0)
					}), {
						root: r,
						rootMargin: o,
						threshold: t,
						trackVisibility: n,
						delay: e
					}, c), () => {
						i && i()
					}
				}), [Array.isArray(t) ? t.toString() : t, p, r, o, s, a, n, c, e]);
				const y = null == (d = v.entry) ? void 0 : d.target,
					x = i.useRef();
				p || !y || s || a || x.current === y || (x.current = y, g({
					inView: !!l,
					entry: void 0
				}));
				const b = [m, v.inView, v.entry];
				return b.ref = b[0], b.inView = b[1], b.entry = b[2], b
			}
		}
	}
]);